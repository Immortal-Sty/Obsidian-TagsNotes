/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VirtFolderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
var identity = (x) => x;
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/environment.js
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;

// node_modules/svelte/src/runtime/internal/loop.js
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data2) {
  return document.createTextNode(data2);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data2) {
  data2 = "" + data2;
  if (text2.data === data2)
    return;
  text2.data = /** @type {string} */
  data2;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/style_manager.js
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = (
      /** @type {Program['d']} */
      program.b - t
    );
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          const opts = { direction: b ? "in" : "out" };
          config = config(opts);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance3, create_fragment3, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment3 ? create_fragment3($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// components/stores.ts
var plugin = writable();
var getPlugin = () => get_store_value(plugin);
var data = writable();
var active_id = writable();

// data.ts
var NoteData = class {
  constructor(base) {
    this.base = base;
  }
  onStartApp() {
    this.base.rescan();
  }
  onCreate(file) {
    this.base.rescan();
  }
  onChange(file) {
    this.base.rescan();
  }
  onRename(file, oldPath) {
    this.base.rescan();
  }
  onDelete(file) {
    this.base.rescan();
  }
};

// onenote.ts
var OneNote = class {
  constructor(id, mtime, ctime, name, title) {
    this.utime = 0;
    // created or used as folder
    this.parents = [];
    this.children = [];
    this.is_pinned = false;
    this.id = id;
    this.mtime = mtime;
    this.name = name;
    this.title = title;
    this.utime = ctime;
  }
  clear() {
    this.parents = [];
    this.children = [];
    this.is_pinned = false;
    this.link = "";
    this.mtime = 0;
    this.utime = 0;
  }
  is_no_parents() {
    return this.parents.length == 0;
  }
  is_no_children() {
    return this.children.length == 0;
  }
  has_children() {
    return this.children.length > 0;
  }
  count_children() {
    return this.children.length;
  }
};

// settings.ts
var import_obsidian = require("obsidian");
var SortTypes = /* @__PURE__ */ ((SortTypes2) => {
  SortTypes2["file_name"] = "file_name";
  SortTypes2["note_title"] = "note_title";
  SortTypes2["creation_time"] = "creation_time";
  SortTypes2["modification_time"] = "modification_time";
  return SortTypes2;
})(SortTypes || {});
var DEFAULT_SETTINGS = {
  ignorePath: "",
  propertyName: "Folders",
  titleProp: "",
  cmdShowTitle: false,
  sortTreeBy: "file_name" /* file_name */,
  sortTreeRev: false,
  UseWikiLinks: true
};
var VirtFolderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin2) {
    super(app, plugin2);
    this.plugin = plugin2;
    this.init_settings();
  }
  init_settings() {
    this.update_filter(this.plugin.settings.ignorePath);
    this.update_prop_name(this.plugin.settings.propertyName);
    this.update_title(this.plugin.settings.titleProp);
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("YAML for  note's folders").setDesc("The name can contain letters, numbers, minus sign, underscore and dots").addText((text2) => {
      text2.setValue(this.plugin.settings.propertyName);
      text2.setPlaceholder("Folders");
      text2.onChange(async (value) => {
        let style = text2.inputEl.style;
        if (this.is_valid_prop_name(value)) {
          style.borderColor = "";
          this.plugin.settings.propertyName = value;
          await this.plugin.saveSettings();
          this.update_prop_name(value);
        } else {
          style.borderColor = this.get_css_var("--background-modifier-error");
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("YAML for note's title").setDesc("Leave the field blank to take the title from the file name").addText((text2) => {
      text2.setValue(this.plugin.settings.titleProp);
      text2.setPlaceholder("Title");
      text2.onChange(async (value) => {
        let style = text2.inputEl.style;
        if (this.is_empty_str(value) || this.is_valid_prop_name(value)) {
          style.borderColor = "";
          this.plugin.settings.titleProp = value;
          await this.plugin.saveSettings();
          this.update_title(value);
        } else {
          style.borderColor = this.get_css_var("--background-modifier-error");
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Use title in commands").setDesc("Display note's title instead of file name when displaying command results").addToggle((tg) => {
      tg.setValue(this.plugin.settings.cmdShowTitle);
      tg.onChange(async (value) => {
        this.plugin.settings.cmdShowTitle = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Sorting").setDesc("Note sorting criteria in the tree view").addDropdown((dc) => {
      for (let key of Object.keys(SortTypes)) {
        dc.addOption(key, key);
      }
      dc.setValue(this.plugin.settings.sortTreeBy);
      dc.onChange(async (value) => {
        this.plugin.settings.sortTreeBy = SortTypes[value];
        await this.plugin.saveSettings();
        this.update_note_list();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Reverse sort order").addToggle((tg) => {
      tg.setValue(this.plugin.settings.sortTreeRev);
      tg.onChange(async (value) => {
        this.plugin.settings.sortTreeRev = value;
        await this.plugin.saveSettings();
        this.update_note_list();
      });
    });
    new import_obsidian.Setting(containerEl).setName("List of ignored paths").setDesc("Each line is interpreted as the start of an ignored path").addTextArea((textArea) => {
      textArea.setValue(this.plugin.settings.ignorePath).setPlaceholder("Enter one or more paths relative to the archive root").onChange(async (value) => {
        this.plugin.settings.ignorePath = value;
        await this.plugin.saveSettings();
        this.update_filter(value);
        this.update_counter();
        this.update_note_list();
      });
      textArea.inputEl.setAttr("rows", 6);
      textArea.inputEl.setAttr("cols", 40);
    });
    new import_obsidian.Setting(containerEl).setName("Ignored files").addText((text2) => {
      text2.setValue("0").setDisabled(true);
      this.counter = text2;
    });
    this.update_counter();
    new import_obsidian.Setting(containerEl).setName("Use [[WikiLinks]] in YAML").addToggle((tg) => {
      tg.setValue(this.plugin.settings.UseWikiLinks);
      tg.onChange(async (value) => {
        this.plugin.settings.UseWikiLinks = value;
        await this.plugin.saveSettings();
        this.update_note_list();
      });
    });
  }
  update_counter() {
    let count = this.plugin.base.get_filtred_count();
    this.counter.setValue(count.toString());
  }
  update_note_list() {
    this.plugin.base.rescan();
    this.plugin.update_data();
  }
  update_filter(value) {
    let filter = this.parse_text_area(value);
    this.plugin.base.settings.set_filter(filter);
  }
  parse_text_area(value) {
    return value.split(/\r|\n/).map((n) => n.trim()).filter((n) => n);
  }
  is_empty_str(name) {
    return name === "";
  }
  is_valid_prop_name(name) {
    let regexp = /^[\w.-]+$/;
    return regexp.test(name);
  }
  update_prop_name(name) {
    if (!this.is_valid_prop_name(name))
      return;
    this.plugin.base.settings.set_prop(name);
    this.update_note_list();
  }
  update_title(value) {
    if (this.is_empty_str(value) || this.is_valid_prop_name(value)) {
      this.plugin.base.settings.set_title(value);
      this.update_note_list();
    }
  }
  get_css_var(variable) {
    let el = document.querySelector("body");
    if (!el)
      return "";
    let style = window.getComputedStyle(el);
    if (!style)
      return "";
    return style.getPropertyValue(variable);
  }
};

// base_scanner.ts
function _is_string(value) {
  return typeof value === "string";
}
var ScanSettings = class {
  constructor() {
    this.filter = [];
    this.title = "";
    this.prop_regexp = void 0;
  }
  set_filter(filter) {
    this.filter = filter;
  }
  set_title(title) {
    this.title = title;
  }
  set_prop(prop) {
    let regexp_str = `^${prop}(\\.\\d+){0,1}$`;
    this.prop_regexp = new RegExp(regexp_str);
  }
  is_valid() {
    return typeof this.prop_regexp !== "undefined";
  }
};
var BaseScanner = class {
  constructor(app, plugin2) {
    this.app = app;
    this.plugin = plugin2;
    this.note_list = {};
    this.top_list = [];
    this.orphans_list = [];
    this.last_active = ["1"];
    this.settings = new ScanSettings();
  }
  test_prop_name(prop_name) {
    if (!this.settings.prop_regexp)
      return false;
    return this.settings.prop_regexp.test(prop_name.trim());
  }
  restore_utime(old_list) {
    for (let id in old_list) {
      if (id in this.note_list) {
        let new_ut = this.note_list[id].utime;
        let old_ut = old_list[id].utime;
        if (old_ut > new_ut) {
          this.note_list[id].utime = old_ut;
        }
      }
    }
  }
  rescan() {
    if (!this.settings.is_valid())
      return;
    let old_list = this.note_list;
    this.init_note_list();
    this.build_links();
    this.build_top();
    this.sort_links();
    this.restore_utime(old_list);
  }
  get_filtred_count() {
    return this.app.vault.getMarkdownFiles().length - this.get_filted_list().length;
  }
  get_filted_list() {
    return this.app.vault.getMarkdownFiles().filter((file) => {
      for (let filter of this.settings.filter) {
        if (file.path.startsWith(filter))
          return false;
      }
      return true;
    });
  }
  get_meta_value(file, prop) {
    let metadata = this.app.metadataCache.getFileCache(file);
    if (metadata && metadata.frontmatter) {
      if (prop in metadata.frontmatter) {
        let value = metadata.frontmatter[prop];
        return _is_string(value) ? value : null;
      }
    }
  }
  // can we get it from Note class?
  get_note_title(file) {
    let name = file.basename;
    let title = this.get_meta_value(file, this.settings.title);
    return title ? title : name;
  }
  link_to_title(value) {
    let link_file = this.app.metadataCache.getFirstLinkpathDest(value, "");
    if (!link_file)
      return value;
    return this.get_note_title(link_file);
  }
  link_to_ctime(value) {
    let link_file = this.app.metadataCache.getFirstLinkpathDest(value, "");
    if (!link_file)
      return 0;
    return link_file.stat.ctime;
  }
  link_to_mtime(value) {
    let link_file = this.app.metadataCache.getFirstLinkpathDest(value, "");
    if (!link_file)
      return 0;
    return link_file.stat.mtime;
  }
  init_note_list() {
    this.note_list = {};
    for (let file of this.get_filted_list()) {
      let file_id = file.path;
      this.note_list[file_id] = new OneNote(
        file_id,
        file.stat.mtime,
        file.stat.ctime,
        file.basename,
        this.get_note_title(file)
      );
    }
  }
  build_links() {
    for (let file of this.get_filted_list()) {
      let file_id = file.path;
      let metadata = this.app.metadataCache.getFileCache(file);
      if (!metadata)
        continue;
      if (metadata.frontmatterLinks) {
        for (let link of metadata.frontmatterLinks) {
          if (!this.test_prop_name(link.key))
            continue;
          let link_file = this.app.metadataCache.getFirstLinkpathDest(link.link, "");
          if (!link_file)
            continue;
          let link_id = link_file.path;
          if (!(link_id in this.note_list))
            continue;
          this.note_list[file_id].parents.push(link_id);
          this.note_list[link_id].children.push(file_id);
        }
      }
      if (metadata.frontmatter) {
        if ("IsPinned" in metadata.frontmatter) {
          let value = metadata.frontmatter["IsPinned"];
          this.note_list[file_id].is_pinned = value != "0" && value != "false";
        }
      }
    }
  }
  is_orphan(note) {
    return note.is_no_parents() && note.is_no_children();
  }
  is_top(note) {
    return note.is_no_parents() && note.has_children();
  }
  is_orphan_or_top(note) {
    return note.is_no_parents();
  }
  build_top() {
    this.orphans_list = [];
    this.top_list = [];
    for (let i in this.note_list) {
      let note = this.note_list[i];
      if (this.is_orphan(note)) {
        this.orphans_list.push(note.id);
        continue;
      }
      if (this.is_top(note)) {
        this.top_list.push(note.id);
      }
    }
  }
  old_l_sort(links) {
    let pinned = [];
    let normal = [];
    for (let id of links) {
      let note = this.note_list[id];
      if (note.is_pinned) {
        pinned.push(id);
      } else {
        normal.push(id);
      }
    }
    pinned.sort();
    normal.sort();
    return pinned.concat(normal);
  }
  l_sort(links) {
    let links_copy = [...links];
    let sortBy = this.plugin.settings.sortTreeBy;
    let sortRev = this.plugin.settings.sortTreeRev;
    if (sortBy == "file_name" /* file_name */) {
      links_copy.sort();
    }
    if (sortBy == "note_title" /* note_title */) {
      links_copy.sort(
        (a, b) => {
          a = this.link_to_title(a);
          b = this.link_to_title(b);
          if (a < b) {
            return -1;
          }
          if (a > b) {
            return 1;
          }
          return 0;
        }
      );
    }
    if (sortBy == "creation_time" /* creation_time */) {
      links_copy.sort(
        (a, b) => {
          return this.link_to_ctime(a) - this.link_to_ctime(b);
        }
      );
    }
    if (sortBy == "modification_time" /* modification_time */) {
      links_copy.sort(
        (a, b) => {
          return this.link_to_mtime(a) - this.link_to_mtime(b);
        }
      );
    }
    if (sortRev)
      links_copy.reverse();
    return links_copy;
  }
  sort_links() {
    for (let id in this.note_list) {
      let note = this.note_list[id];
      note.children = this.l_sort(note.children);
    }
    this.orphans_list = this.l_sort(this.orphans_list);
    this.top_list = this.l_sort(this.top_list);
  }
  note_by_id(id) {
    if (id in this.note_list) {
      return this.note_list[id];
    }
  }
  is_same_mtime(file) {
    let id = file.path;
    let note = this.note_by_id(id);
    if (!note)
      return false;
    return note.mtime == file.stat.mtime;
  }
  _count_unique(arr) {
    return new Set(arr).size;
  }
  _is_recursion(arr) {
    return this._count_unique(arr) != arr.length;
  }
  _build_path(note, path, path_list) {
    if (this._is_recursion(path))
      return;
    if (this.is_orphan(note)) {
      let new_path = ["orphan_dir"].concat(path);
      path_list.push(new_path);
      return;
    }
    if (this.is_top(note)) {
      let new_path = ["top_dir"].concat(path);
      path_list.push(new_path);
      return;
    }
    for (let parent of note.parents) {
      let sub_note = this.note_by_id(parent);
      if (!sub_note)
        continue;
      let new_path = [sub_note.id].concat(path);
      this._build_path(sub_note, new_path, path_list);
    }
  }
  build_path_list(id) {
    let note = this.note_by_id(id);
    if (!note)
      return void 0;
    let path_list = [];
    this._build_path(note, [note.id], path_list);
    return path_list;
  }
  _get_min_path(path_list) {
    let min_path = [];
    let min_count = 999;
    for (let path of path_list) {
      let len = path.length;
      if (len < min_count) {
        min_count = len;
        min_path = path;
      }
    }
    return min_path.slice();
  }
  get_shortest_path(id) {
    let path_list = this.build_path_list(id);
    ;
    if (!path_list)
      return void 0;
    let path = this._get_min_path(path_list);
    return path;
  }
  _array_index(path_list, old_path) {
    for (let i in path_list) {
      let path = path_list[i];
      if (path.join("/") == old_path.join("/")) {
        return parseInt(i);
      }
    }
  }
  _next_index(path_len, old_index) {
    return path_len > old_index + 1 ? old_index + 1 : 0;
  }
  _split_into_parents(path_list) {
    let parent_list = {};
    for (let path of path_list) {
      let parent = path[path.length - 2];
      if (!(parent in parent_list))
        parent_list[parent] = [];
      parent_list[parent].push(path);
    }
    return parent_list;
  }
  _get_shoretest_list(path_list) {
    let parent_list = this._split_into_parents(path_list);
    let shortest_list = [];
    for (let parent in parent_list) {
      let path_parent = parent_list[parent];
      shortest_list.push(this._get_min_path(path_parent));
    }
    return shortest_list;
  }
  get_next_path(id) {
    let path_list = this.build_path_list(id);
    if (!path_list)
      return void 0;
    path_list = this._get_shoretest_list(path_list);
    let old_index = this._array_index(path_list, this.last_active);
    let path = void 0;
    if (old_index === void 0) {
      path = this._get_min_path(path_list);
    } else {
      let next_index = this._next_index(path_list.length, old_index);
      path = path_list[next_index];
    }
    this.last_active = path.slice();
    return path;
  }
};

// select_file_modal.ts
var import_obsidian2 = require("obsidian");
var VF_SelectFile = class extends import_obsidian2.FuzzySuggestModal {
  constructor(plugin2, onSubmit) {
    super(plugin2.app);
    this.plugin = plugin2;
    this.onSubmit = onSubmit;
    this.selected = "";
    this.setPlaceholder("Type note's title");
  }
  getAliases(note) {
  }
  getItemName(item) {
    if (this.plugin.settings.cmdShowTitle)
      return item.title;
    return item.name;
  }
  getItemText(item) {
    return this.getItemName(item);
  }
  getItems() {
    let notes = [];
    for (let id in this.plugin.base.note_list) {
      notes.push(this.plugin.base.note_list[id]);
    }
    notes.sort(function(a, b) {
      return b.utime - a.utime;
    });
    return notes;
  }
  onChooseItem(item, evt) {
    this.onSubmit(item.id);
  }
  _format_parents(parents) {
    let links = [];
    for (let id of parents) {
      let note = this.plugin.base.note_by_id(id);
      if (!note)
        continue;
      links.push(this.getItemName(note));
    }
    return links;
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: this.getItemName(item.item) });
    let small = el.createEl("small", { cls: "vf_search_parents" });
    for (let parent of item.item.parents) {
      let path = this.plugin.base.get_shortest_path(parent);
      let links = this._format_parents(path);
      let line = small.createEl("div", { cls: "vf_serach_div" });
      for (let id of links) {
        line.createEl("span", { text: id, cls: "vf_serach_link" });
      }
    }
  }
};

// select_prop_modal.ts
var import_obsidian3 = require("obsidian");
function get_link_base(link) {
  let regexp_1 = /(?:\[\[(.+?)\||\[\[(.+?)\]\]|\[.+?\]\((.+?)\))/;
  let result = null;
  let match = regexp_1.exec(link);
  if (match) {
    if (match[1])
      result = match[1];
    if (match[2])
      result = match[2];
    if (match[3])
      result = match[3];
  }
  return result;
}
var VF_SelectPropModal = class extends import_obsidian3.SuggestModal {
  constructor(plugin2, yamlProp, onSubmit) {
    super(plugin2.app);
    this.plugin = plugin2;
    this.yamlProp = yamlProp;
    this.onSubmit = onSubmit;
    this.app = plugin2.app;
    this.useMarkdownLinks = this.app.vault.getConfig("useMarkdownLinks");
    this.setPlaceholder("Select one to remove");
  }
  open() {
    this.plugin.yaml.get_links(this.yamlProp, (links) => {
      if (links.length == 0) {
        new import_obsidian3.Notice(`${this.yamlProp} is empty`);
        return;
      }
      if (links.length == 1) {
        this.onSubmit(links[0]);
        return;
      }
      super.open();
    });
  }
  async getSuggestions(query) {
    let notes = [];
    let file = this.app.workspace.getActiveFile();
    if (file) {
      await this.app.fileManager.processFrontMatter(file, (fm) => {
        this._get_prop_list(fm, this.yamlProp);
      });
      for (let item of this.prop_list) {
        let name = get_link_base(item);
        if (!name)
          continue;
        notes.push({ name, full: item });
      }
    }
    return notes;
  }
  getItemName(item) {
    if (!this.plugin.settings.cmdShowTitle)
      return item.name;
    return this.plugin.base.link_to_title(item.name);
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: this.getItemName(item) });
  }
  onChooseSuggestion(item, evt) {
    this.onSubmit(item.full);
  }
  _get_prop_list(front, prop) {
    if (prop in front && front[prop]) {
      this.prop_list = front[prop];
    } else {
      this.prop_list = [];
    }
  }
};

// tree_view.ts
var import_obsidian5 = require("obsidian");

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/svelte/src/runtime/easing/index.js
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/src/runtime/transition/index.js
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map(
    (e) => `${e[0].toUpperCase()}${e.slice(1)}`
  );
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(
    style[`border${capitalized_secondary_properties[0]}Width`]
  );
  const border_width_end_value = parseFloat(
    style[`border${capitalized_secondary_properties[1]}Width`]
  );
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}

// components/Note.svelte
var import_obsidian4 = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-to9axs", ".counter.svelte-to9axs{text-align:right;margin-left:auto;background-color:var(--background-secondary-alt);position:sticky;top:0;color:var(--text-normal);padding:2px 4px}.current_note.svelte-to9axs{background-color:var(--background-secondary-alt)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  child_ctx[28] = list;
  child_ctx[29] = i;
  return child_ctx;
}
function create_if_block_2(ctx) {
  let div;
  let collapsedIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "tree-item-icon collapse-icon");
      toggle_class(
        div,
        "is-collapsed",
        /*isCollapsed*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(div, "click", stop_propagation(
            /*click_handler*/
            ctx[19]
          )),
          action_destroyer(collapsedIcon_action = /*collapsedIcon*/
          ctx[9].call(null, div))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*isCollapsed*/
      4) {
        toggle_class(
          div,
          "is-collapsed",
          /*isCollapsed*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*childCounter*/
        ctx[4]
      );
      attr(span, "class", "counter svelte-to9axs");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*childCounter*/
      16)
        set_data(
          t,
          /*childCounter*/
          ctx2[4]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_transition;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*childList*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*child*/
    ctx2[27]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "introstart",
            /*expandTransitionStart*/
            ctx[10]
          ),
          listen(
            div,
            "introend",
            /*introend_handler*/
            ctx[22]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*childList, build_path, children*/
      2208) {
        each_value = ensure_array_like(
          /*childList*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration: 100 }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 100 }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(key_1, ctx) {
  let first;
  let note_1;
  let child = (
    /*child*/
    ctx[27]
  );
  let current;
  const assign_note_1 = () => (
    /*note_1_binding*/
    ctx[21](note_1, child)
  );
  const unassign_note_1 = () => (
    /*note_1_binding*/
    ctx[21](null, child)
  );
  let note_1_props = {
    id: (
      /*child*/
      ctx[27]
    ),
    node_path: (
      /*build_path*/
      ctx[11](
        /*child*/
        ctx[27]
      )
    )
  };
  note_1 = new Note({ props: note_1_props });
  assign_note_1();
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(note_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(note_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (child !== /*child*/
      ctx[27]) {
        unassign_note_1();
        child = /*child*/
        ctx[27];
        assign_note_1();
      }
      const note_1_changes = {};
      if (dirty & /*childList*/
      32)
        note_1_changes.id = /*child*/
        ctx[27];
      if (dirty & /*childList*/
      32)
        note_1_changes.node_path = /*build_path*/
        ctx[11](
          /*child*/
          ctx[27]
        );
      note_1.$set(note_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(note_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(note_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      unassign_note_1();
      destroy_component(note_1, detaching);
    }
  };
}
function create_fragment(ctx) {
  let div2;
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let div1_class_value;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*childCounter*/
    ctx[4] > 0 && create_if_block_2(ctx)
  );
  let if_block1 = (
    /*childCounter*/
    ctx[4] > 0 && create_if_block_1(ctx)
  );
  let if_block2 = (
    /*childCounter*/
    ctx[4] > 0 && !/*isCollapsed*/
    ctx[2] && create_if_block(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = text(
        /*title*/
        ctx[1]
      );
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "tree-item-inner");
      attr(div1, "class", div1_class_value = "tree-item-self is-clickable mod-collapsible " + /*IsOpened*/
      (ctx[3] ? "current_note" : "") + " svelte-to9axs");
      attr(div2, "class", "tree-item is-clickable");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, t1);
      append(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append(div2, t3);
      if (if_block2)
        if_block2.m(div2, null);
      ctx[23](div2);
      current = true;
      if (!mounted) {
        dispose = listen(
          div1,
          "click",
          /*click_handler_1*/
          ctx[20]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*childCounter*/
        ctx2[4] > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*title*/
      2)
        set_data(
          t1,
          /*title*/
          ctx2[1]
        );
      if (
        /*childCounter*/
        ctx2[4] > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*IsOpened*/
      8 && div1_class_value !== (div1_class_value = "tree-item-self is-clickable mod-collapsible " + /*IsOpened*/
      (ctx2[3] ? "current_note" : "") + " svelte-to9axs")) {
        attr(div1, "class", div1_class_value);
      }
      if (
        /*childCounter*/
        ctx2[4] > 0 && !/*isCollapsed*/
        ctx2[2]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*childCounter, isCollapsed*/
          20) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[23](null);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $data;
  let $active_id;
  component_subscribe($$self, data, ($$value) => $$invalidate(17, $data = $$value));
  component_subscribe($$self, active_id, ($$value) => $$invalidate(18, $active_id = $$value));
  let { id = "unknown-link-id" } = $$props;
  let { type = "sub_note" } = $$props;
  let { node_path = [] } = $$props;
  let plugin2 = getPlugin();
  let note;
  let title = id;
  let isCollapsed = true;
  let IsOpened = false;
  let childCounter = 0;
  let childList = [];
  let myElement;
  const children2 = {};
  const collapsedIcon = function(node) {
    node.appendChild((0, import_obsidian4.getIcon)("right-triangle"));
  };
  let expandTransitionWaiter = Promise.resolve();
  let expandTransitionEnd;
  function expandTransitionStart() {
    expandTransitionWaiter = new Promise((resolve) => {
      $$invalidate(8, expandTransitionEnd = resolve);
    });
  }
  function build_path(id2) {
    return node_path.concat([id2]);
  }
  function openNote(id2, new_tab = false) {
    if (type == "top_dir" || type == "orphan_dir") {
      return;
    }
    plugin2.app.workspace.openLinkText(id2, id2, new_tab);
  }
  function scrollIntoMiddle() {
    let elementRect = myElement.getBoundingClientRect();
    let absoluteElementTop = elementRect.top + window.scrollY;
    let middle = absoluteElementTop - window.innerHeight / 2;
    myElement.win.scrollTo(0, middle);
  }
  const focusNotes = (pathNotes) => __awaiter(void 0, void 0, void 0, function* () {
    $$invalidate(2, isCollapsed = false);
    yield tick();
    let next = pathNotes.shift();
    if (pathNotes.length === 0)
      yield expandTransitionWaiter;
    if (!next) {
      if (myElement) {
        myElement.scrollIntoView({ block: "center" });
      }
      return;
    }
    if (next in children2) {
      children2[next].focusNotes(pathNotes);
    }
  });
  const click_handler = () => {
    $$invalidate(2, isCollapsed = !isCollapsed);
  };
  const click_handler_1 = (event) => {
    if (event.shiftKey) {
      openNote(id, false);
      return;
    }
    if (event.ctrlKey) {
      openNote(id, true);
      return;
    }
    $$invalidate(2, isCollapsed = false);
    openNote(id);
  };
  function note_1_binding($$value, child) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      children2[child] = $$value;
      $$invalidate(7, children2);
    });
  }
  const introend_handler = () => {
    expandTransitionEnd();
  };
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      myElement = $$value;
      $$invalidate(6, myElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("type" in $$props2)
      $$invalidate(13, type = $$props2.type);
    if ("node_path" in $$props2)
      $$invalidate(14, node_path = $$props2.node_path);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id, $active_id, type, $data, note*/
    466945) {
      $: {
        $$invalidate(3, IsOpened = id == $active_id);
        if (type == "top_dir") {
          $$invalidate(1, title = "ROOT");
          $$invalidate(4, childCounter = $data.top_list.length);
          $$invalidate(5, childList = $data.top_list);
        }
        if (type == "orphan_dir") {
          $$invalidate(1, title = "Orphans");
          $$invalidate(4, childCounter = $data.orphans_list.length);
          $$invalidate(5, childList = $data.orphans_list);
        }
        if (type == "sub_note") {
          $$invalidate(16, note = $data.note_list[id]);
          if (note) {
            $$invalidate(1, title = note.title);
            $$invalidate(4, childCounter = note.count_children());
            $$invalidate(5, childList = note.children);
          }
        }
      }
    }
  };
  return [
    id,
    title,
    isCollapsed,
    IsOpened,
    childCounter,
    childList,
    myElement,
    children2,
    expandTransitionEnd,
    collapsedIcon,
    expandTransitionStart,
    build_path,
    openNote,
    type,
    node_path,
    focusNotes,
    note,
    $data,
    $active_id,
    click_handler,
    click_handler_1,
    note_1_binding,
    introend_handler,
    div2_binding
  ];
}
var Note = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        id: 0,
        type: 13,
        node_path: 14,
        focusNotes: 15
      },
      add_css
    );
  }
  get focusNotes() {
    return this.$$.ctx[15];
  }
};
var Note_default = Note;

// components/Component.svelte
function create_if_block2(ctx) {
  let note;
  let t;
  let if_block_anchor;
  let current;
  let note_props = { type: "top_dir", node_path: ["top_dir"] };
  note = new Note_default({ props: note_props });
  ctx[3](note);
  let if_block = (
    /*$data*/
    ctx[1].orphans_list.length && create_if_block_12(ctx)
  );
  return {
    c() {
      create_component(note.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(note, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const note_changes = {};
      note.$set(note_changes);
      if (
        /*$data*/
        ctx2[1].orphans_list.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$data*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(note.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(note.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      ctx[3](null);
      destroy_component(note, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let note;
  let current;
  let note_props = {
    type: "orphan_dir",
    node_path: ["orphan_dir"]
  };
  note = new Note_default({ props: note_props });
  ctx[4](note);
  return {
    c() {
      create_component(note.$$.fragment);
    },
    m(target, anchor) {
      mount_component(note, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const note_changes = {};
      note.$set(note_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(note.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(note.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[4](null);
      destroy_component(note, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$data*/
    ctx[1] !== void 0 && create_if_block2(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$data*/
        ctx2[1] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$data*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $data;
  component_subscribe($$self, data, ($$value) => $$invalidate(1, $data = $$value));
  const children2 = {};
  function focusTo(pathNotes) {
    let first = pathNotes.shift();
    if (!first)
      return;
    children2[first].focusNotes(pathNotes);
  }
  function note_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      children2["top_dir"] = $$value;
      $$invalidate(0, children2);
    });
  }
  function note_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      children2["orphan_dir"] = $$value;
      $$invalidate(0, children2);
    });
  }
  return [children2, $data, focusTo, note_binding, note_binding_1];
}
var Component = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { focusTo: 2 });
  }
  get focusTo() {
    return this.$$.ctx[2];
  }
};
var Component_default = Component;

// tree_view.ts
var TREE_ICON = "folder-tree";
var VIEW_TYPE_VF = "virt-folder-view";
var VirtFolderView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin2) {
    super(leaf);
    this.plugin = plugin2;
    this.icon = TREE_ICON;
  }
  getViewType() {
    return VIEW_TYPE_VF;
  }
  getDisplayText() {
    return "VirtFolder";
  }
  async onOpen() {
    plugin.set(this.plugin);
    this.component = new Component_default({
      target: this.contentEl
    });
  }
  async onClose() {
    this.component.$destroy();
  }
  getComponent() {
    return this.component;
  }
};

// yaml_parser.ts
var import_obsidian6 = require("obsidian");
var YamlParser = class {
  constructor(app, plugin2) {
    this.app = app;
    this.plugin = plugin2;
  }
  showMessage(msg) {
    new import_obsidian6.Notice(msg);
  }
  _fm_add_link(front, selected, prop) {
    let file = this.app.vault.getFileByPath(selected);
    if (!file)
      return;
    let link = this.app.metadataCache.fileToLinktext(file, "");
    let formated_link = `[[${link}]]`;
    if (!this.plugin.settings.UseWikiLinks) {
      formated_link = `[${link}](${link})`;
    }
    if (prop in front && front[prop]) {
      if (front[prop].contains(formated_link)) {
        this.showMessage(`${prop}'s link already exist`);
        return;
      }
    } else {
      front[prop] = [];
    }
    front[prop].push(formated_link);
    this.showMessage(`Set ${prop}: ${link}`);
  }
  add_link(yamlProp, file_id) {
    let file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    this.app.fileManager.processFrontMatter(file, (fm) => {
      this._fm_add_link(fm, file_id, yamlProp);
    });
  }
  _fm_replace_link(front, selected, prop, old_link) {
    let file = this.app.vault.getFileByPath(selected);
    if (!file)
      return;
    let link = this.app.metadataCache.fileToLinktext(file, "");
    let formated_link = `[[${link}]]`;
    if (!this.plugin.settings.UseWikiLinks) {
      formated_link = `[${link}](${link})`;
    }
    if (prop in front && front[prop]) {
      if (front[prop].contains(formated_link)) {
        this.showMessage(`${prop}'s link already exist`);
        return;
      }
      if (!front[prop].contains(old_link)) {
        this.showMessage(`Can't find ${old_link} in ${prop}`);
        return;
      }
      let i = front[prop].indexOf(old_link);
      front[prop][i] = formated_link;
      this.showMessage(`Set ${prop}: ${link}`);
    } else {
      front[prop] = [];
    }
  }
  replace_link(yamlProp, old_link, file_id) {
    let file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    this.app.fileManager.processFrontMatter(file, (fm) => {
      this._fm_replace_link(fm, file_id, yamlProp, old_link);
    });
  }
  _fm_get_links(front, prop) {
    if (prop in front && front[prop]) {
      return front[prop];
    } else {
      return [];
    }
  }
  get_links(yamlProp, callback) {
    let file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    this.app.fileManager.processFrontMatter(file, (fm) => {
      callback(this._fm_get_links(fm, yamlProp));
    });
  }
  _fm_remove_link(front, prop, old_link) {
    if (prop in front && front[prop]) {
      if (front[prop].contains(old_link)) {
        front[prop].remove(old_link);
        this.showMessage(`${prop}'s link removed`);
      } else {
        this.showMessage(`${prop}'s link not exist`);
      }
    }
  }
  remove_link(yamlProp, old_link) {
    let file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    this.app.fileManager.processFrontMatter(file, (fm) => {
      this._fm_remove_link(fm, yamlProp, old_link);
    });
  }
};

// main.ts
var VirtFolderPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.onOpenFile = (file) => {
      this.setActiveFile(file);
    };
    this.onCreateFile = (file) => {
      if (file instanceof import_obsidian7.TFile) {
        this.data.onCreate(file);
        this.update_data();
      }
    };
    this.onDeleteFile = (file) => {
      if (file instanceof import_obsidian7.TFile) {
        this.data.onDelete(file);
        this.update_data();
      }
    };
    this.onRenameFile = (file, oldPath) => {
      if (file instanceof import_obsidian7.TFile) {
        this.data.onRename(file, oldPath);
        this.update_data();
      }
    };
    this.onResolveMetadata = (file) => {
      if (this.base.is_same_mtime(file)) {
        return;
      }
      this.data.onChange(file);
      this.update_data();
    };
  }
  async onload() {
    await this.loadSettings();
    this.base = new BaseScanner(this.app, this);
    this.data = new NoteData(this.base);
    this.yaml = new YamlParser(this.app, this);
    this.addSettingTab(new VirtFolderSettingTab(this.app, this));
    this.registerView(
      VIEW_TYPE_VF,
      (leaf) => new VirtFolderView(leaf, this)
    );
    this.addCommand({
      id: "open_tree_view",
      name: "Show tree",
      icon: "folder-tree",
      callback: () => {
        this.VF_OpenTreeView();
      }
    });
    this.addCommand({
      id: "add_folder",
      name: "Add folder",
      icon: "folder-plus",
      callback: () => {
        this.VF_AddFolder();
      }
    });
    this.addCommand({
      id: "replace_folder",
      name: "Move folder",
      icon: "folder-output",
      callback: () => {
        this.VF_MoveFolder();
      }
    });
    this.addCommand({
      id: "remove_folder",
      name: "Delete folder",
      icon: "folder-minus",
      callback: () => {
        this.VF_RemoveFolder();
      }
    });
    this.addCommand({
      id: "reveal_active_file",
      name: "Reveal file",
      icon: "folder-search-2",
      callback: () => {
        this.VF_RevealActiveFile();
      }
    });
    this.app.workspace.onLayoutReady(() => {
      this.data.onStartApp();
      this.update_data();
      this.registerEvent(this.app.metadataCache.on("resolve", this.onResolveMetadata));
      this.registerEvent(this.app.workspace.on("file-open", this.onOpenFile, this));
      this.registerEvent(this.app.vault.on("create", this.onCreateFile));
      this.registerEvent(this.app.vault.on("delete", this.onDeleteFile));
      this.registerEvent(this.app.vault.on("rename", this.onRenameFile));
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  updateActiveFile() {
    let file = this.app.workspace.getActiveFile();
    if (file)
      active_id.set(file.path);
    else
      active_id.set("");
  }
  setActiveFile(file) {
    if (file instanceof import_obsidian7.TFile) {
      active_id.set(file.path);
    } else {
      active_id.set("");
    }
  }
  update_data() {
    data.set(this.base);
    this.updateActiveFile();
  }
  revealFile(path) {
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_VF)) {
      if (!(leaf.view instanceof VirtFolderView))
        continue;
      leaf.view.component.focusTo(path);
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_VF);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeftLeaf(false);
      if (leaf)
        await leaf.setViewState({ type: VIEW_TYPE_VF, active: true });
    }
    if (leaf)
      workspace.revealLeaf(leaf);
  }
  VF_OpenTreeView() {
    this.activateView();
  }
  VF_RevealActiveFile() {
    this.activateView();
    let file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    let path = this.base.get_next_path(file.path);
    if (path)
      this.revealFile(path);
  }
  updateUsedTime(file_id) {
    this.base.note_list[file_id].utime = Date.now();
  }
  VF_AddFolder() {
    let file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    new VF_SelectFile(
      this,
      (file_id) => {
        this.yaml.add_link(this.settings.propertyName, file_id);
        this.updateUsedTime(file_id);
        this.update_data();
      }
    ).open();
  }
  VF_MoveFolder() {
    let file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    new VF_SelectPropModal(
      this,
      this.settings.propertyName,
      (old_link) => {
        new VF_SelectFile(
          this,
          (file_id) => {
            this.yaml.replace_link(this.settings.propertyName, old_link, file_id);
            this.updateUsedTime(file_id);
            this.update_data();
          }
        ).open();
      }
    ).open();
  }
  VF_RemoveFolder() {
    new VF_SelectPropModal(
      this,
      this.settings.propertyName,
      (old_link) => {
        this.yaml.remove_link(this.settings.propertyName, old_link);
        this.update_data();
      }
    ).open();
  }
};


/* nosourcemap */