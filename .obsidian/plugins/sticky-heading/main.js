/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StickyHeadingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/HeadingPlugin.ts
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var headingExp = /^header_header-(\d)$/;
var OBSIDIAN_STICKY_HEADING_CLASS = "obsidian-sticky-heading";
var CONTENT_CLASS = "cm-content";
function getDistanceFromContentToScroller(view) {
  const scroller = view.scrollDOM;
  const contentContainer = view.scrollDOM.querySelector(`.${CONTENT_CLASS}`);
  let distance = 0;
  if (scroller == null || contentContainer == null) {
    return distance;
  }
  let currentElement = contentContainer;
  while (currentElement != null && currentElement != scroller) {
    distance += currentElement.offsetTop;
    currentElement = currentElement.offsetParent;
  }
  return distance;
}
function HeadingPlugin(settings) {
  return import_view.ViewPlugin.fromClass(
    class HeadingViewPlugin {
      constructor(view) {
        let dom = document.createElement("div");
        dom.classList.add(OBSIDIAN_STICKY_HEADING_CLASS);
        this.settings = settings;
        this.stickyDom = dom;
        this.view = view;
        this.init(view);
      }
      init(view) {
        view.dom.appendChild(this.stickyDom);
        view.scrollDOM.addEventListener("scroll", this.handleScroll.bind(this));
        this.updateHeaders(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || update.heightChanged) {
          this.updateHeaders(update.view);
        }
      }
      destroy() {
        this.stickyDom.remove();
      }
      handleScroll(event) {
        this.updateHeaders(this.view);
      }
      updateStickyDom() {
        const dom = document.createElement("div");
        dom.classList.add(`${OBSIDIAN_STICKY_HEADING_CLASS}_inner`);
        this.headings.forEach(([level, text]) => {
          const header = document.createElement("div");
          header.classList.add("HyperMD-header", `HyperMD-header-${level}`);
          const headerContent = document.createElement("div");
          headerContent.classList.add("cm-header", `cm-header-${level}`);
          const levelDom = document.createElement("div");
          levelDom.classList.add(`${OBSIDIAN_STICKY_HEADING_CLASS}_level`);
          levelDom.textContent = `h${level}`;
          headerContent.appendChild(levelDom);
          const textDom = document.createElement("div");
          textDom.classList.add(`${OBSIDIAN_STICKY_HEADING_CLASS}_text`);
          textDom.textContent = text;
          headerContent.appendChild(textDom);
          header.appendChild(headerContent);
          dom.appendChild(header);
        });
        this.stickyDom.replaceChildren(dom);
      }
      updateHeaders(view) {
        let editorView = view || this.view;
        if (editorView) {
          let headerChanged = false;
          editorView.requestMeasure({
            read: () => {
              const oldHeadings = JSON.stringify(this.headings);
              this.findHeaders(editorView);
              if (oldHeadings !== JSON.stringify(this.headings)) {
                headerChanged = true;
              }
            },
            write: () => {
              headerChanged && this.updateStickyDom();
            }
          });
        }
      }
      findHeaders(view) {
        let distance = getDistanceFromContentToScroller(view);
        const headings = [];
        let stickyHeadingEl = view.dom.querySelector(`.${OBSIDIAN_STICKY_HEADING_CLASS}`);
        const stickyHeadingContentHeight = (stickyHeadingEl == null ? void 0 : stickyHeadingEl.clientHeight) || 20;
        let height = view.scrollDOM.scrollTop - distance + stickyHeadingContentHeight;
        const firstElementBlockInfo = view.elementAtHeight(height);
        let meetHeadersByDomQuery = false;
        const headerOutViewList = [];
        (0, import_language.syntaxTree)(view.state).iterate({
          from: 0,
          to: firstElementBlockInfo.from,
          enter(node) {
            if (meetHeadersByDomQuery) {
              return;
            }
            let regExpExecArray = headingExp.exec(node.name);
            if (regExpExecArray) {
              const level = Number(regExpExecArray[1]);
              const text = view.state.sliceDoc(node.from, node.to).trim();
              headerOutViewList.unshift([level, text]);
            }
          }
        });
        const type = settings.stickyType;
        let biggestLevel = Number.MAX_SAFE_INTEGER;
        for (let i = 0; i < headerOutViewList.length; i++) {
          const value = headerOutViewList[i];
          if (type === "prev") {
            headings.unshift(value);
            break;
          } else if (type === "prevToH1") {
            const level = value[0];
            if (level < biggestLevel) {
              headings.unshift(value);
              biggestLevel = level;
            }
          }
        }
        this.headings = headings;
        return headings;
      }
    }
  );
}

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  stickyType: "prev"
};
var StickyHeadingSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Plugin Settings" });
    new import_obsidian.Setting(containerEl).setName("Sticky Type").setDesc("prev: show prev heading; prevToH1: show prev headings until h1;").addDropdown((dropdown) => {
      dropdown.addOption("prev", "prev");
      dropdown.addOption("prevToH1", "prevToH1");
      dropdown.setValue(this.plugin.settings.stickyType);
      dropdown.onChange(async (value) => {
        this.plugin.settings.stickyType = value;
        await this.plugin.saveSettings(this.plugin.settings);
      });
    });
    containerEl.createEl("h2", { text: "Plugin Style Settings" });
    const styleEl = containerEl.createEl("div");
    styleEl.addClass("callout");
    styleEl.setAttribute("data-callout", "warning");
    styleEl.createEl("div", { text: "\u{1F514} Notice: You need to install [Style Settings plugin](https://github.com/mgmeyers/obsidian-style-settings) to config style" });
    styleEl.addClass("callout-title");
  }
};

// main.ts
var StickyHeadingPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new StickyHeadingSettingTab(this.app, this));
    this.app.workspace.trigger("parse-style-settings");
    this.registerEditorExtension([HeadingPlugin(this.settings)]);
  }
  onunload() {
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  async saveSettings(settings) {
    Object.assign(this.settings, settings);
    await this.saveData(this.settings);
  }
};
