/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn2.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Lineage
});
module.exports = __toCommonJS(main_exports);
var import_obsidian14 = require("obsidian");

// src/view/view.ts
var import_obsidian7 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys2) {
  const rest = {};
  keys2 = new Set(keys2);
  for (const k in props)
    if (!keys2.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    return this._observer ?? (this._observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        this._listeners.get(entry.target)?.(entry);
      }
    }));
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block11, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block11(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance58, create_fragment58, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance58 ? instance58(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment58 ? create_fragment58($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  const type = props_definition[prop]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i][0];
  child_ctx[11] = list[i][1];
  return child_ctx;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_levels = [
    /*attrs*/
    ctx[11]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = svg_element(
        /*tag*/
        ctx[10]
      );
      set_svg_attributes(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*iconNode*/
      32 && /*attrs*/
      ctx2[11]]));
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
    }
  };
}
function create_each_block(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[10]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*tag*/
    ctx[10] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[10]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[10]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[10];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let svg;
  let each_1_anchor;
  let svg_stroke_width_value;
  let svg_class_value;
  let current;
  let each_value = ensure_array_like(
    /*iconNode*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let svg_levels = [
    defaultAttributes_default,
    /*$$restProps*/
    ctx[6],
    { width: (
      /*size*/
      ctx[2]
    ) },
    { height: (
      /*size*/
      ctx[2]
    ) },
    { stroke: (
      /*color*/
      ctx[1]
    ) },
    {
      "stroke-width": svg_stroke_width_value = /*absoluteStrokeWidth*/
      ctx[4] ? Number(
        /*strokeWidth*/
        ctx[3]
      ) * 24 / Number(
        /*size*/
        ctx[2]
      ) : (
        /*strokeWidth*/
        ctx[3]
      )
    },
    {
      class: svg_class_value = `lucide-icon lucide lucide-${/*name*/
      ctx[0]} ${/*$$props*/
      ctx[7].class ?? ""}`
    }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append(svg, each_1_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*iconNode*/
      32) {
        each_value = ensure_array_like(
          /*iconNode*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(svg, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        defaultAttributes_default,
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*size*/
        4) && { width: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*size*/
        4) && { height: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*color*/
        2) && { stroke: (
          /*color*/
          ctx2[1]
        ) },
        (!current || dirty & /*absoluteStrokeWidth, strokeWidth, size*/
        28 && svg_stroke_width_value !== (svg_stroke_width_value = /*absoluteStrokeWidth*/
        ctx2[4] ? Number(
          /*strokeWidth*/
          ctx2[3]
        ) * 24 / Number(
          /*size*/
          ctx2[2]
        ) : (
          /*strokeWidth*/
          ctx2[3]
        ))) && { "stroke-width": svg_stroke_width_value },
        (!current || dirty & /*name, $$props*/
        129 && svg_class_value !== (svg_class_value = `lucide-icon lucide lucide-${/*name*/
        ctx2[0]} ${/*$$props*/
        ctx2[7].class ?? ""}`)) && { class: svg_class_value }
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "color", "size", "strokeWidth", "absoluteStrokeWidth", "iconNode"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { color = "currentColor" } = $$props;
  let { size = 24 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { absoluteStrokeWidth = false } = $$props;
  let { iconNode } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(3, strokeWidth = $$new_props.strokeWidth);
    if ("absoluteStrokeWidth" in $$new_props)
      $$invalidate(4, absoluteStrokeWidth = $$new_props.absoluteStrokeWidth);
    if ("iconNode" in $$new_props)
      $$invalidate(5, iconNode = $$new_props.iconNode);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    color,
    size,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode,
    $$restProps,
    $$props,
    $$scope,
    slots
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 0,
      color: 1,
      size: 2,
      strokeWidth: 3,
      absoluteStrokeWidth: 4,
      iconNode: 5
    });
  }
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/icons/arrow-left.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-left" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m12 19-7-7 7-7" }], ["path", { "d": "M19 12H5" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_left = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var arrow_left_default = Arrow_left;

// node_modules/lucide-svelte/dist/icons/arrow-right.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }], ["path", { "d": "m12 5 7 7-7 7" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
  }
};
var arrow_right_default = Arrow_right;

// node_modules/lucide-svelte/dist/icons/chevron-down.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m6 9 6 6 6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var chevron_down_default = Chevron_down;

// node_modules/lucide-svelte/dist/icons/chevron-right.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var chevron_right_default = Chevron_right;

// node_modules/lucide-svelte/dist/icons/chevron-up.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m18 15-6-6-6 6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
  }
};
var chevron_up_default = Chevron_up;

// node_modules/lucide-svelte/dist/icons/file-minus.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-minus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M9 15h6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_minus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var file_minus_default = File_minus;

// node_modules/lucide-svelte/dist/icons/file-output.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-output" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M4 7V4a2 2 0 0 1 2-2 2 2 0 0 0-2 2"
      }
    ],
    [
      "path",
      {
        "d": "M4.063 20.999a2 2 0 0 0 2 1L18 22a2 2 0 0 0 2-2V7l-5-5H6"
      }
    ],
    ["path", { "d": "m5 11-3 3" }],
    ["path", { "d": "m5 17-3-3h10" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_output = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
  }
};
var file_output_default = File_output;

// node_modules/lucide-svelte/dist/icons/file-pen.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment9(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-pen" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M12 22h6a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v10"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M10.4 12.6a2 2 0 1 1 3 3L8 21l-4 1 1-4Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_pen = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
  }
};
var file_pen_default = File_pen;

// node_modules/lucide-svelte/dist/icons/file-plus.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment10(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-plus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M9 15h6" }],
    ["path", { "d": "M12 18v-6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_plus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
  }
};
var file_plus_default = File_plus;

// node_modules/lucide-svelte/dist/icons/file-question.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment11(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-question" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    [
      "path",
      {
        "d": "M10 10.3c.2-.4.5-.8.9-1a2.1 2.1 0 0 1 2.6.4c.3.4.5.8.5 1.3 0 1.3-2 2-2 2"
      }
    ],
    ["path", { "d": "M12 17h.01" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_question = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
  }
};
var file_question_default = File_question;

// node_modules/lucide-svelte/dist/icons/file-up.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment12(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M12 12v6" }],
    ["path", { "d": "m15 15-3-3-3 3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
  }
};
var file_up_default = File_up;

// node_modules/lucide-svelte/dist/icons/file.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment13(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
  }
};
var file_default = File;

// node_modules/lucide-svelte/dist/icons/history.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment14(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "history" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }],
    ["path", { "d": "M12 7v5l4 2" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var History = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
  }
};
var history_default = History;

// node_modules/lucide-svelte/dist/icons/keyboard.svelte
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment15(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "keyboard" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M10 8h.01" }],
    ["path", { "d": "M12 12h.01" }],
    ["path", { "d": "M14 8h.01" }],
    ["path", { "d": "M16 12h.01" }],
    ["path", { "d": "M18 8h.01" }],
    ["path", { "d": "M6 8h.01" }],
    ["path", { "d": "M7 16h10" }],
    ["path", { "d": "M8 12h.01" }],
    [
      "rect",
      {
        "x": "2",
        "y": "4",
        "width": "20",
        "height": "16",
        "rx": "2"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Keyboard = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
  }
};
var keyboard_default = Keyboard;

// node_modules/lucide-svelte/dist/icons/maximize.svelte
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment16(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "maximize" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M8 3H5a2 2 0 0 0-2 2v3" }],
    ["path", { "d": "M21 8V5a2 2 0 0 0-2-2h-3" }],
    ["path", { "d": "M3 16v3a2 2 0 0 0 2 2h3" }],
    ["path", { "d": "M16 21h3a2 2 0 0 0 2-2v-3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Maximize = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
  }
};
var maximize_default = Maximize;

// node_modules/lucide-svelte/dist/icons/merge.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment17(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "merge" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m8 6 4-4 4 4" }],
    [
      "path",
      {
        "d": "M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22"
      }
    ],
    ["path", { "d": "m20 22-5-5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Merge = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, {});
  }
};
var merge_default = Merge;

// node_modules/lucide-svelte/dist/icons/pen.svelte
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment18(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pen" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pen = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
  }
};
var pen_default = Pen;

// node_modules/lucide-svelte/dist/icons/pencil.svelte
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment19(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pencil" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"
      }
    ],
    ["path", { "d": "m15 5 4 4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pencil = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, {});
  }
};
var pencil_default = Pencil;

// node_modules/lucide-svelte/dist/icons/redo.svelte
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment20(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "redo" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M21 7v6h-6" }],
    [
      "path",
      {
        "d": "M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Redo = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
  }
};
var redo_default = Redo;

// node_modules/lucide-svelte/dist/icons/rotate-ccw.svelte
function create_default_slot20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment21(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "rotate-ccw" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot20] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Rotate_ccw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
  }
};
var rotate_ccw_default = Rotate_ccw;

// node_modules/lucide-svelte/dist/icons/save.svelte
function create_default_slot21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment22(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "save" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"
      }
    ],
    ["polyline", { "points": "17 21 17 13 7 13 7 21" }],
    ["polyline", { "points": "7 3 7 8 15 8" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Save = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment22, safe_not_equal, {});
  }
};
var save_default = Save;

// node_modules/lucide-svelte/dist/icons/search.svelte
function create_default_slot22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment23(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "search" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "11", "cy": "11", "r": "8" }],
    ["path", { "d": "m21 21-4.3-4.3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Search = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, {});
  }
};
var search_default = Search;

// node_modules/lucide-svelte/dist/icons/trash.svelte
function create_default_slot23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment24(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "trash" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M3 6h18" }],
    [
      "path",
      {
        "d": "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"
      }
    ],
    [
      "path",
      {
        "d": "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Trash = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment24, safe_not_equal, {});
  }
};
var trash_default = Trash;

// node_modules/lucide-svelte/dist/icons/undo.svelte
function create_default_slot24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment25(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "undo" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot24] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M3 7v6h6" }],
    [
      "path",
      {
        "d": "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Undo = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment25, safe_not_equal, {});
  }
};
var undo_default = Undo;

// node_modules/lucide-svelte/dist/icons/x.svelte
function create_default_slot25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment26(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "x" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M18 6 6 18" }], ["path", { "d": "m6 6 12 12" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var X = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment26, safe_not_equal, {});
  }
};
var x_default = X;

// node_modules/lucide-svelte/dist/icons/zoom-in.svelte
function create_default_slot26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment27(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "zoom-in" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "11", "cy": "11", "r": "8" }],
    [
      "line",
      {
        "x1": "21",
        "x2": "16.65",
        "y1": "21",
        "y2": "16.65"
      }
    ],
    [
      "line",
      {
        "x1": "11",
        "x2": "11",
        "y1": "8",
        "y2": "14"
      }
    ],
    [
      "line",
      {
        "x1": "8",
        "x2": "14",
        "y1": "11",
        "y2": "11"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Zoom_in = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment27, safe_not_equal, {});
  }
};
var zoom_in_default = Zoom_in;

// node_modules/lucide-svelte/dist/icons/zoom-out.svelte
function create_default_slot27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment28(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "zoom-out" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot27] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "11", "cy": "11", "r": "8" }],
    [
      "line",
      {
        "x1": "21",
        "x2": "16.65",
        "y1": "21",
        "y2": "16.65"
      }
    ],
    [
      "line",
      {
        "x1": "8",
        "x2": "14",
        "y1": "11",
        "y2": "11"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Zoom_out = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment28, safe_not_equal, {});
  }
};
var zoom_out_default = Zoom_out;

// src/view/components/container/context.ts
var getPlugin = () => {
  return getContext("plugin");
};
var getView = () => {
  return getContext("view");
};

// src/lang/lang.ts
var lang = {
  open_in_editor: "Open in editor",
  open_in_lineage: "Open in Lineage",
  toggle_lineage_view: "Toggle view",
  remove_structural_comments: "Export document",
  create_new_file: "Create new file",
  new_file: "New lineage file"
};

// src/stores/view/reducers/ui/change-zoom-level.ts
var zoomStep = 0.1;
var maxZoomLevel = 2;
var minZoomLevel = 0.1;
var changeZoomLevel = (state, payload) => {
  if ("value" in payload) {
    state.ui.zoomLevel = payload.value;
  } else {
    state.ui.zoomLevel = payload.direction === "in" ? Math.min(state.ui.zoomLevel + zoomStep, maxZoomLevel) : Math.max(state.ui.zoomLevel - zoomStep, minZoomLevel);
  }
};

// src/obsidian/events/workspace/helpers/set-file-view-type.ts
var setFileViewType = (plugin, file, leaf, newViewType) => {
  plugin.settings.dispatch({
    type: newViewType === "markdown" ? "SET_DOCUMENT_TYPE_TO_MARKDOWN" : "SET_DOCUMENT_TYPE_TO_TREE",
    payload: {
      path: file.path
    }
  });
  if (leaf) {
    setTimeout(() => {
      leaf.setViewState({
        type: newViewType,
        popstate: true,
        state: leaf.view.getState()
      });
      plugin.app.workspace.revealLeaf(leaf);
    }, 0);
  }
};

// src/view/components/container/controls-bar/controls-bar.svelte
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-45uovx", "button.svelte-45uovx:disabled{cursor:not-allowed;color:var(--color-base-40)}.controls-container.svelte-45uovx{right:var(--size-4-2);top:var(--size-4-2);gap:var(--size-4-2);display:flex;flex-direction:column;position:absolute;z-index:2}.lineage-view-control-group.svelte-45uovx{border-radius:var(--radius-s);background-color:var(--background-primary);border:1px solid var(--background-modifier-border);box-shadow:var(--input-shadow);display:flex;flex-direction:column;overflow:hidden}.control-item.svelte-45uovx{border-radius:0;box-shadow:none;height:auto;display:flex;line-height:1;font-size:inherit;align-items:center;justify-content:center;padding:var(--size-4-2);border-bottom:1px solid var(--background-modifier-border);color:var(--text-muted);background-color:var(--interactive-normal);--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width);cursor:pointer}.control-item.svelte-45uovx:last-child{border-bottom:none}");
}
function create_fragment29(ctx) {
  let div3;
  let div0;
  let button0;
  let file;
  let button0_aria_label_value;
  let t0;
  let button1;
  let keyboard;
  let t1;
  let div1;
  let button2;
  let historyicon;
  let button2_disabled_value;
  let t2;
  let button3;
  let undoicon;
  let button3_disabled_value;
  let t3;
  let button4;
  let redoicon;
  let button4_disabled_value;
  let t4;
  let div2;
  let button5;
  let zoomin;
  let button5_disabled_value;
  let t5;
  let button6;
  let rotateccw;
  let t6;
  let button7;
  let maximize;
  let t7;
  let button8;
  let zoomout;
  let button8_disabled_value;
  let current;
  let mounted;
  let dispose;
  file = new file_default({ props: { class: "svg-icon" } });
  keyboard = new keyboard_default({ props: { class: "svg-icon" } });
  historyicon = new history_default({ props: { class: "svg-icon" } });
  undoicon = new undo_default({ props: { class: "svg-icon" } });
  redoicon = new redo_default({ props: { class: "svg-icon" } });
  zoomin = new zoom_in_default({ props: { class: "svg-icon" } });
  rotateccw = new rotate_ccw_default({ props: { class: "svg-icon" } });
  maximize = new maximize_default({ props: { class: "svg-icon" } });
  zoomout = new zoom_out_default({ props: { class: "svg-icon" } });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      button0 = element("button");
      create_component(file.$$.fragment);
      t0 = space();
      button1 = element("button");
      create_component(keyboard.$$.fragment);
      t1 = space();
      div1 = element("div");
      button2 = element("button");
      create_component(historyicon.$$.fragment);
      t2 = space();
      button3 = element("button");
      create_component(undoicon.$$.fragment);
      t3 = space();
      button4 = element("button");
      create_component(redoicon.$$.fragment);
      t4 = space();
      div2 = element("div");
      button5 = element("button");
      create_component(zoomin.$$.fragment);
      t5 = space();
      button6 = element("button");
      create_component(rotateccw.$$.fragment);
      t6 = space();
      button7 = element("button");
      create_component(maximize.$$.fragment);
      t7 = space();
      button8 = element("button");
      create_component(zoomout.$$.fragment);
      attr(button0, "aria-label", button0_aria_label_value = lang.open_in_editor);
      attr(button0, "class", "control-item svelte-45uovx");
      attr(button0, "data-tooltip-position", "left");
      attr(button1, "aria-label", "Keyboard shortcuts");
      attr(button1, "class", "control-item svelte-45uovx");
      attr(button1, "data-tooltip-position", "left");
      attr(div0, "class", "lineage-view-control-group svelte-45uovx");
      attr(button2, "aria-label", "History");
      attr(button2, "class", "control-item svelte-45uovx");
      attr(button2, "data-tooltip-position", "left");
      button2.disabled = button2_disabled_value = /*documentHistory*/
      ctx[0].items.length === 0;
      attr(button3, "aria-label", "Undo");
      attr(button3, "class", "control-item svelte-45uovx");
      attr(button3, "data-tooltip-position", "left");
      button3.disabled = button3_disabled_value = !/*documentHistory*/
      ctx[0] || !/*documentHistory*/
      ctx[0].state.canGoBack;
      attr(button4, "aria-label", "Redo");
      attr(button4, "class", "control-item svelte-45uovx");
      attr(button4, "data-tooltip-position", "left");
      button4.disabled = button4_disabled_value = !/*documentHistory*/
      ctx[0] || !/*documentHistory*/
      ctx[0].state.canGoForward;
      attr(div1, "class", "lineage-view-control-group svelte-45uovx");
      attr(button5, "aria-label", "zoom in");
      attr(button5, "class", "control-item svelte-45uovx");
      attr(button5, "data-tooltip-position", "left");
      button5.disabled = button5_disabled_value = /*$viewStore*/
      ctx[1].ui.zoomLevel === maxZoomLevel;
      attr(button6, "aria-label", "Restore zoom level");
      attr(button6, "class", "control-item svelte-45uovx");
      attr(button6, "data-tooltip-position", "left");
      attr(button7, "aria-label", "Zoom to fit");
      attr(button7, "class", "control-item svelte-45uovx");
      attr(button7, "data-tooltip-position", "left");
      attr(button8, "aria-label", "Zoom out");
      attr(button8, "class", "control-item svelte-45uovx");
      attr(button8, "data-tooltip-position", "left");
      button8.disabled = button8_disabled_value = /*$viewStore*/
      ctx[1].ui.zoomLevel === minZoomLevel;
      attr(div2, "class", "lineage-view-control-group svelte-45uovx");
      attr(div3, "class", "controls-container svelte-45uovx");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, button0);
      mount_component(file, button0, null);
      append(div0, t0);
      append(div0, button1);
      mount_component(keyboard, button1, null);
      append(div3, t1);
      append(div3, div1);
      append(div1, button2);
      mount_component(historyicon, button2, null);
      append(div1, t2);
      append(div1, button3);
      mount_component(undoicon, button3, null);
      append(div1, t3);
      append(div1, button4);
      mount_component(redoicon, button4, null);
      append(div3, t4);
      append(div3, div2);
      append(div2, button5);
      mount_component(zoomin, button5, null);
      append(div2, t5);
      append(div2, button6);
      mount_component(rotateccw, button6, null);
      append(div2, t6);
      append(div2, button7);
      mount_component(maximize, button7, null);
      append(div2, t7);
      append(div2, button8);
      mount_component(zoomout, button8, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*openAsMarkdown*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*toggleHelp*/
            ctx[5]
          ),
          listen(
            button2,
            "click",
            /*click_handler*/
            ctx[12]
          ),
          listen(
            button3,
            "click",
            /*handlePreviousClick*/
            ctx[4]
          ),
          listen(
            button4,
            "click",
            /*handleNextClick*/
            ctx[3]
          ),
          listen(
            button5,
            "click",
            /*zoomIn*/
            ctx[7]
          ),
          listen(
            button6,
            "click",
            /*restoreZoom*/
            ctx[9]
          ),
          listen(
            button7,
            "click",
            /*fitToScale*/
            ctx[10]
          ),
          listen(
            button8,
            "click",
            /*zoomOut*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*documentHistory*/
      1 && button2_disabled_value !== (button2_disabled_value = /*documentHistory*/
      ctx2[0].items.length === 0)) {
        button2.disabled = button2_disabled_value;
      }
      if (!current || dirty & /*documentHistory*/
      1 && button3_disabled_value !== (button3_disabled_value = !/*documentHistory*/
      ctx2[0] || !/*documentHistory*/
      ctx2[0].state.canGoBack)) {
        button3.disabled = button3_disabled_value;
      }
      if (!current || dirty & /*documentHistory*/
      1 && button4_disabled_value !== (button4_disabled_value = !/*documentHistory*/
      ctx2[0] || !/*documentHistory*/
      ctx2[0].state.canGoForward)) {
        button4.disabled = button4_disabled_value;
      }
      if (!current || dirty & /*$viewStore*/
      2 && button5_disabled_value !== (button5_disabled_value = /*$viewStore*/
      ctx2[1].ui.zoomLevel === maxZoomLevel)) {
        button5.disabled = button5_disabled_value;
      }
      if (!current || dirty & /*$viewStore*/
      2 && button8_disabled_value !== (button8_disabled_value = /*$viewStore*/
      ctx2[1].ui.zoomLevel === minZoomLevel)) {
        button8.disabled = button8_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(file.$$.fragment, local);
      transition_in(keyboard.$$.fragment, local);
      transition_in(historyicon.$$.fragment, local);
      transition_in(undoicon.$$.fragment, local);
      transition_in(redoicon.$$.fragment, local);
      transition_in(zoomin.$$.fragment, local);
      transition_in(rotateccw.$$.fragment, local);
      transition_in(maximize.$$.fragment, local);
      transition_in(zoomout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(file.$$.fragment, local);
      transition_out(keyboard.$$.fragment, local);
      transition_out(historyicon.$$.fragment, local);
      transition_out(undoicon.$$.fragment, local);
      transition_out(redoicon.$$.fragment, local);
      transition_out(zoomin.$$.fragment, local);
      transition_out(rotateccw.$$.fragment, local);
      transition_out(maximize.$$.fragment, local);
      transition_out(zoomout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(file);
      destroy_component(keyboard);
      destroy_component(historyicon);
      destroy_component(undoicon);
      destroy_component(redoicon);
      destroy_component(zoomin);
      destroy_component(rotateccw);
      destroy_component(maximize);
      destroy_component(zoomout);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let $viewStore;
  const view = getView();
  const viewStore = view.viewStore;
  component_subscribe($$self, viewStore, (value) => $$invalidate(1, $viewStore = value));
  const documentStore = view.documentStore;
  let { documentHistory } = $$props;
  let { path } = $$props;
  const handleNextClick = () => {
    if (path) {
      if (viewStore.getValue().document.editing.activeNodeId)
        new import_obsidian.Notice("cannot apply snapshot while editing");
      else
        documentStore.dispatch({ type: "HISTORY/APPLY_NEXT_SNAPSHOT" });
    }
  };
  const handlePreviousClick = () => {
    if (path) {
      if (viewStore.getValue().document.editing.activeNodeId)
        new import_obsidian.Notice("cannot apply snapshot while editing");
      else
        documentStore.dispatch({ type: "HISTORY/APPLY_PREVIOUS_SNAPSHOT" });
    }
  };
  const plugin = getPlugin();
  const toggleHelp = () => {
    viewStore.dispatch({ type: "UI/TOGGLE_HELP_SIDEBAR" });
  };
  const openAsMarkdown = () => {
    var _a;
    const file = (_a = plugin.app.workspace.getActiveViewOfType(LineageView)) === null || _a === void 0 ? void 0 : _a.file;
    if (file)
      setFileViewType(plugin, file, view.leaf, "markdown");
  };
  const zoomIn = () => {
    viewStore.dispatch({
      type: "UI/CHANGE_ZOOM_LEVEL",
      payload: { direction: "in" }
    });
  };
  const zoomOut = () => {
    viewStore.dispatch({
      type: "UI/CHANGE_ZOOM_LEVEL",
      payload: { direction: "out" }
    });
  };
  const restoreZoom2 = () => {
    viewStore.dispatch({
      type: "UI/CHANGE_ZOOM_LEVEL",
      payload: { value: 1 }
    });
  };
  const fitToScale = () => {
    restoreZoom2();
    const columns = Array.from(view.containerEl.querySelectorAll(".column"));
    if (columns.length) {
      const scrolls = columns.map((c) => c.scrollHeight).sort();
      const biggest = scrolls[scrolls.length - 1];
      const scale = window.innerHeight / biggest;
      viewStore.dispatch({
        type: "UI/CHANGE_ZOOM_LEVEL",
        payload: { value: scale }
      });
    }
  };
  const click_handler = () => {
    viewStore.dispatch({ type: "UI/TOGGLE_HISTORY_SIDEBAR" });
  };
  $$self.$$set = ($$props2) => {
    if ("documentHistory" in $$props2)
      $$invalidate(0, documentHistory = $$props2.documentHistory);
    if ("path" in $$props2)
      $$invalidate(11, path = $$props2.path);
  };
  return [
    documentHistory,
    $viewStore,
    viewStore,
    handleNextClick,
    handlePreviousClick,
    toggleHelp,
    openAsMarkdown,
    zoomIn,
    zoomOut,
    restoreZoom2,
    fitToScale,
    path,
    click_handler
  ];
}
var Controls_bar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance29, create_fragment29, safe_not_equal, { documentHistory: 0, path: 11 }, add_css);
  }
};
var controls_bar_default = Controls_bar;

// src/helpers/store/derived.ts
var derived = (source, mapper, actions) => {
  const set = new Set(actions);
  const subscribers = /* @__PURE__ */ new Set();
  let derivedValue;
  let unsub = null;
  return {
    subscribe: (run2) => {
      subscribers.add(run2);
      if (!unsub) {
        unsub = source.subscribe((value, action, initialRun) => {
          if (action && set.has(action?.type) || initialRun) {
            derivedValue = mapper(value, action);
            for (const sub of subscribers) {
              sub(derivedValue, action, initialRun);
            }
          }
        });
      }
      run2(derivedValue, void 0, true);
      return () => {
        subscribers.delete(run2);
        if (unsub && subscribers.size === 0) {
          unsub();
          unsub = null;
        }
      };
    }
  };
};

// src/helpers/store/store.ts
var Store = class {
  constructor(initialValue2, reducer, onError) {
    this.subscribers = /* @__PURE__ */ new Set();
    this.isProcessing = false;
    this.actionQueue = [];
    this.reducer = () => this.value;
    // eslint-disable-next-line no-console
    this.onError = (error) => console.error(error);
    this.value = initialValue2;
    if (reducer)
      this.reducer = reducer;
    if (onError)
      this.onError = onError;
  }
  getValue() {
    return this.value;
  }
  dispatch(action) {
    this.actionQueue.push(action);
    if (!this.isProcessing) {
      this.processActionQueue();
    }
  }
  set(value) {
    this.value = value;
    this.notifySubscribers();
  }
  subscribe(run2, invalidate) {
    this.subscribers.add(run2);
    try {
      run2(this.value, void 0, true);
    } catch (error) {
      this.onError(error, "subscriber");
    }
    return () => {
      this.subscribers.delete(run2);
    };
  }
  update(updater) {
    this.value = updater(this.value);
    this.notifySubscribers();
  }
  processActionQueue() {
    this.isProcessing = true;
    while (this.actionQueue.length > 0) {
      const action = this.actionQueue.shift();
      try {
        this.value = this.reducer(this.value, action);
        this.notifySubscribers(action);
      } catch (error) {
        this.onError(error, "reducer", action);
      }
    }
    this.isProcessing = false;
  }
  notifySubscribers(action) {
    for (const subscriber of this.subscribers) {
      try {
        subscriber(this.value, action);
      } catch (error) {
        this.onError(error, "subscriber", action);
      }
    }
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/is-editing.ts
var isEditing = (view) => {
  return !!view.viewStore.getValue().document.editing.activeNodeId;
};
var isActive = (view) => {
  return !!view.viewStore.getValue().document.activeNode;
};
var isActiveAndNotEditing = (view) => {
  return isActive(view) && !isEditing(view);
};
var isActiveAndEditing = (view) => {
  return isActive(view) && isEditing(view);
};
var isActiveAndNotEditingAndHasFile = (view) => {
  return isActiveAndNotEditing(view) && !!view.documentStore.getValue().file.path;
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/navigate-commands.ts
var navigateCommands = () => {
  const commands = [];
  commands.push(
    {
      name: "go_right",
      check: isActiveAndNotEditing,
      callback: (view) => {
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "right",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [
        { key: "L", modifiers: [] },
        { key: "ArrowRight", modifiers: [] }
      ]
    },
    {
      name: "go_down",
      check: isActiveAndNotEditing,
      callback: (view) => {
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "down",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [
        { key: "J", modifiers: [] },
        { key: "ArrowDown", modifiers: [] }
      ]
    },
    {
      name: "go_left",
      check: isActiveAndNotEditing,
      callback: (view) => {
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "left",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [
        { key: "H", modifiers: [] },
        { key: "ArrowLeft", modifiers: [] }
      ]
    },
    {
      name: "go_up",
      check: isActiveAndNotEditing,
      callback: (view) => {
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "up",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [
        { key: "K", modifiers: [] },
        { key: "ArrowUp", modifiers: [] }
      ]
    },
    {
      name: "go_to_beginning_of_group",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "start-of-group",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [{ key: "PageUp", modifiers: [] }]
    },
    {
      name: "go_to_end_of_group",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "end-of-group",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [{ key: "PageDown", modifiers: [] }]
    },
    {
      name: "go_to_beginning_of_column",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "start-of-column",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [{ key: "Home", modifiers: [] }]
    },
    {
      name: "go_to_end_of_column",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "end-of-column",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [{ key: "End", modifiers: [] }]
    }
  );
  return commands;
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/cancel-changes.ts
var discardChanges = (view) => {
  view.inlineEditor.unloadNode();
};
var cancelChanges = (view) => {
  discardChanges(view);
  view.viewStore.dispatch({
    type: "DOCUMENT/DISABLE_EDIT_MODE"
  });
};

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/save-node-content.ts
var saveNodeContent = (view) => {
  if (view.inlineEditor.activeNode) {
    const content = view.inlineEditor.getContent();
    const nodeId = view.inlineEditor.activeNode;
    invariant(nodeId);
    discardChanges(view);
    view.viewStore.dispatch({
      type: "DOCUMENT/DISABLE_EDIT_MODE"
    });
    view.documentStore.dispatch({
      type: "DOCUMENT/SET_NODE_CONTENT",
      payload: {
        nodeId,
        content
      }
    });
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/edit-commands.ts
var editCommands = () => {
  return [
    {
      name: "enable_edit_mode",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "DOCUMENT/ENABLE_EDIT_MODE",
          payload: {
            nodeId: view.viewStore.getValue().document.activeNode
          }
        });
      },
      hotkeys: [{ key: "Enter", modifiers: [] }]
    },
    {
      name: "save_changes_and_exit_card",
      check: isActiveAndEditing,
      callback: (view) => {
        saveNodeContent(view);
      },
      hotkeys: [{ key: "Enter", modifiers: ["Shift", "Ctrl"] }]
    },
    {
      name: "disable_edit_mode",
      check: isActiveAndEditing,
      callback: (view) => {
        cancelChanges(view);
      },
      hotkeys: [{ key: "Escape", modifiers: [] }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/save-node-and-insert-node.ts
var saveNodeAndInsertNode = (view, direction, content = "") => {
  if (isEditing(view)) {
    saveNodeContent(view);
  }
  view.documentStore.dispatch({
    type: "DOCUMENT/INSERT_NODE",
    payload: {
      position: direction,
      content,
      activeNodeId: view.viewStore.getValue().document.activeNode
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/add-node-and-split-at-cursor.ts
var flattenEditorPosition = (value, cursor) => {
  const lines = value.split("\n");
  let total = 0;
  for (let i = 0; i < lines.length; i++) {
    if (cursor.line === i) {
      return total + cursor.ch;
    } else {
      total += lines[i].length;
    }
  }
  throw new Error(`invalid cursor line: ${cursor.line} ch: ${cursor.ch}`);
};
var addNodeAndSplitAtCursor = (view, direction) => {
  let text2 = "";
  let firstHalf = "", secondHalf = "";
  const value = view.inlineEditor.getContent();
  const cursor = flattenEditorPosition(value, view.inlineEditor.getCursor());
  if (cursor < value.length) {
    firstHalf = value.substring(0, cursor);
    secondHalf = value.substring(cursor);
    if (direction === "up") {
      view.inlineEditor.setContent(secondHalf);
      text2 = firstHalf;
    } else {
      view.inlineEditor.setContent(firstHalf);
      text2 = secondHalf;
    }
  }
  saveNodeAndInsertNode(view, direction, text2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/create-commands.ts
var createCommands = () => {
  return [
    {
      name: "add_above",
      check: isActiveAndNotEditing,
      callback: (view) => {
        saveNodeAndInsertNode(view, "up");
      },
      hotkeys: [
        {
          key: "ArrowUp",
          modifiers: ["Ctrl"]
        }
      ]
    },
    {
      name: "add_below",
      check: isActiveAndNotEditing,
      callback: (view) => {
        saveNodeAndInsertNode(view, "down");
      },
      hotkeys: [
        {
          key: "ArrowDown",
          modifiers: ["Ctrl"]
        }
      ]
    },
    {
      name: "add_child",
      check: isActiveAndNotEditing,
      callback: (view) => {
        saveNodeAndInsertNode(view, "right");
      },
      hotkeys: [
        {
          key: "ArrowRight",
          modifiers: ["Ctrl"]
        }
      ]
    },
    {
      name: "add_above_and_split",
      check: isActive,
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "up");
        else
          saveNodeAndInsertNode(view, "up");
      },
      hotkeys: [{ key: "K", modifiers: ["Ctrl"] }]
    },
    {
      name: "add_below_and_split",
      check: isActive,
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "down");
        else
          saveNodeAndInsertNode(view, "down");
      },
      hotkeys: [{ key: "J", modifiers: ["Ctrl"] }]
    },
    {
      name: "add_child_and_split",
      check: isActive,
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "right");
        else
          saveNodeAndInsertNode(view, "right");
      },
      hotkeys: [{ key: "L", modifiers: ["Ctrl"] }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/move-node.ts
var moveNode = (view, direction) => {
  saveNodeContent(view);
  view.documentStore.dispatch({
    type: "DOCUMENT/MOVE_NODE",
    payload: {
      direction,
      activeNodeId: view.viewStore.getValue().document.activeNode
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/move-commands.ts
var moveCommands = () => {
  return [
    {
      name: "move_node_up",
      check: isActive,
      callback: (view) => {
        moveNode(view, "up");
      },
      hotkeys: [
        { key: "K", modifiers: ["Alt", "Shift"] },
        { key: "ArrowUp", modifiers: ["Alt", "Shift"] }
      ]
    },
    {
      name: "move_node_down",
      check: isActive,
      callback: (view) => {
        moveNode(view, "down");
      },
      hotkeys: [
        { key: "J", modifiers: ["Alt", "Shift"] },
        { key: "ArrowDown", modifiers: ["Alt", "Shift"] }
      ]
    },
    {
      name: "move_node_right",
      check: isActive,
      callback: (view) => {
        moveNode(view, "right");
      },
      hotkeys: [
        { key: "L", modifiers: ["Alt", "Shift"] },
        { key: "ArrowRight", modifiers: ["Alt", "Shift"] }
      ]
    },
    {
      name: "move_node_left",
      check: isActive,
      callback: (view) => {
        moveNode(view, "left");
      },
      hotkeys: [
        { key: "H", modifiers: ["Alt", "Shift"] },
        { key: "ArrowLeft", modifiers: ["Alt", "Shift"] }
      ]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/merge-node.ts
var mergeNode = (view, direction) => {
  saveNodeContent(view);
  view.documentStore.dispatch({
    type: "DOCUMENT/MERGE_NODE",
    payload: {
      direction,
      activeNodeId: view.viewStore.getValue().document.activeNode
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/merge-commands.ts
var mergeCommands = () => {
  return [
    {
      name: "merge_with_node_above",
      check: isActive,
      callback: (view) => {
        mergeNode(view, "up");
      },
      hotkeys: [
        { key: "K", modifiers: ["Ctrl", "Shift"] },
        { key: "ArrowUp", modifiers: ["Ctrl", "Shift"] }
      ]
    },
    {
      name: "merge_with_node_below",
      check: isActive,
      callback: (view) => {
        mergeNode(view, "down");
      },
      hotkeys: [
        { key: "J", modifiers: ["Ctrl", "Shift"] },
        { key: "ArrowDown", modifiers: ["Ctrl", "Shift"] }
      ]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/history-commands.ts
var historyCommands = () => {
  return [
    {
      name: "undo_change",
      check: isActiveAndNotEditingAndHasFile,
      callback: (view) => {
        const path = view.documentStore.getValue().file.path;
        if (path)
          view.documentStore.dispatch({
            type: "HISTORY/APPLY_PREVIOUS_SNAPSHOT"
          });
      },
      hotkeys: [{ key: "Z", modifiers: ["Ctrl", "Shift"] }]
    },
    {
      name: "redo_change",
      check: isActiveAndNotEditingAndHasFile,
      callback: (view) => {
        const path = view.documentStore.getValue().file.path;
        if (path)
          view.documentStore.dispatch({
            type: "HISTORY/APPLY_NEXT_SNAPSHOT"
          });
      },
      hotkeys: [{ key: "Y", modifiers: ["Ctrl", "Shift"] }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/load-commands.ts
var pluginCommands = {
  current: null
};
var loadCommands = (plugin) => {
  pluginCommands.current = [
    ...navigateCommands(),
    ...editCommands(),
    ...createCommands(),
    ...moveCommands(),
    ...mergeCommands(),
    ...historyCommands(),
    {
      name: "delete_card",
      check: isActiveAndNotEditing,
      callback: (view) => {
        view.documentStore.dispatch({
          type: "DOCUMENT/DELETE_NODE",
          payload: {
            activeNodeId: view.viewStore.getValue().document.activeNode
          }
        });
      },
      hotkeys: [{ key: "Backspace", modifiers: ["Ctrl"] }]
    },
    {
      name: "toggle_search_input",
      check: isActive,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({ type: "SEARCH/TOGGLE_INPUT" });
      },
      hotkeys: [{ key: "/", modifiers: [] }]
    }
  ];
  hotkeyStore.dispatch({
    type: "SETTINGS/LOAD_CUSTOM_HOTKEYS",
    payload: {
      customHotkeys: plugin.settings.getValue().hotkeys.customHotkeys
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/hotkey-to-string.ts
var hotkeyToString = (hotkey) => hotkey.key.toUpperCase() + hotkey.modifiers.sort().map((x) => x === "Mod" ? "Ctrl" : x).join("");

// src/stores/hotkeys/reducers/update-hotkey.ts
var updateHotkey = (state, action) => {
  const commandHotkeys = state.hotkeys.find(
    (hotkey) => hotkey.name === action.payload.command
  );
  if (!commandHotkeys)
    return;
  let customHotkeys = state.customHotkeys[action.payload.command];
  if (!customHotkeys) {
    customHotkeys = {};
    state.customHotkeys[action.payload.command] = customHotkeys;
  }
  const newHotkey = {
    modifiers: action.payload.hotkey.modifiers,
    key: action.payload.hotkey.key,
    string_representation: hotkeyToString(action.payload.hotkey)
  };
  const index = action.payload.primary ? 0 : 1;
  commandHotkeys.hotkeys[index] = newHotkey;
  if (action.payload.primary) {
    customHotkeys.primary = action.payload.hotkey;
  } else {
    customHotkeys.secondary = action.payload.hotkey;
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/command-names.ts
var hotkeysLang = {
  save_changes_and_exit_card: "Save changes and exit card",
  // toggle_edit_mode: 'Toggle edit',
  enable_edit_mode: "Edit card",
  disable_edit_mode: "Cancel changes",
  add_child: "Add child",
  add_below: "Add card below",
  add_above: "Add card above",
  add_child_and_split: "Add child and split at cursor",
  add_below_and_split: "Add card below and split at cursor",
  add_above_and_split: "Add card above and split at cursor",
  delete_card: "Delete card",
  go_up: "Go up",
  go_down: "Go down",
  go_right: "Go right",
  go_left: "Go left",
  undo_change: "Undo change",
  redo_change: "Redo change",
  move_node_up: "Move card up",
  move_node_down: "Move card down",
  move_node_right: "Move card right",
  move_node_left: "Move card left",
  merge_with_node_above: "Merge with card above",
  merge_with_node_below: "Merge with card below",
  toggle_search_input: "Search",
  go_to_beginning_of_group: "Go to beginning of group",
  go_to_end_of_group: "Go to end of group",
  go_to_beginning_of_column: "Go to beginning of column",
  go_to_end_of_column: "Go to end of column"
};
var groupedHotkeys = {
  "Create cards": /* @__PURE__ */ new Set([
    "add_child",
    "add_below",
    "add_above",
    "add_child_and_split",
    "add_below_and_split",
    "add_above_and_split"
  ]),
  "Edit cards": /* @__PURE__ */ new Set([
    "enable_edit_mode",
    "disable_edit_mode",
    "save_changes_and_exit_card"
  ]),
  "Move cards": /* @__PURE__ */ new Set([
    "move_node_up",
    "move_node_down",
    "move_node_right",
    "move_node_left"
  ]),
  "Merge cards": /* @__PURE__ */ new Set(["merge_with_node_above", "merge_with_node_below"]),
  "Delete cards": /* @__PURE__ */ new Set(["delete_card"]),
  Navigation: /* @__PURE__ */ new Set([
    "go_up",
    "go_down",
    "go_right",
    "go_left",
    "go_to_beginning_of_group",
    "go_to_end_of_group",
    "go_to_beginning_of_column",
    "go_to_end_of_column"
  ]),
  history: /* @__PURE__ */ new Set(["undo_change", "redo_change"]),
  search: /* @__PURE__ */ new Set(["toggle_search_input"])
};
var hotkeysGroups = Object.fromEntries(
  Object.entries(groupedHotkeys).map(([group, commands]) => Array.from(commands).map((c) => [c, group])).flat()
);

// src/stores/hotkeys/reducers/helpers/command-to-hotkeys.ts
var commandToHotkeys = (command) => {
  return {
    name: command.name,
    hotkeys: command.hotkeys.map((h) => ({
      string_representation: hotkeyToString(h),
      key: h.key,
      modifiers: [...h.modifiers]
    })),
    group: hotkeysGroups[command.name]
  };
};

// src/stores/hotkeys/reducers/load-custom-hotkeys.ts
var loadCustomHotkeys = (state, action) => {
  for (const [name, customHotkey] of Object.entries(
    action.payload.customHotkeys
  )) {
    if (customHotkey.primary || customHotkey.secondary) {
      state.customHotkeys[name] = customHotkey;
    }
  }
  if (!pluginCommands.current)
    throw new Error("plugin commands are undefined");
  state.hotkeys = [];
  for (const pluginCommand of pluginCommands.current) {
    const hotkey = commandToHotkeys(pluginCommand);
    state.hotkeys.push(hotkey);
    const customHotkey = state.customHotkeys[hotkey.name];
    if (customHotkey) {
      updateHotkey(state, {
        type: "HOTKEY/UPDATE",
        payload: {
          command: hotkey.name,
          hotkey: customHotkey.primary || customHotkey.secondary,
          primary: !!customHotkey.primary
        }
      });
    }
  }
};

// src/stores/hotkeys/reducers/reset-hotkey.ts
var resetHotkey = (state, action) => {
  const hotkey = state.hotkeys.find(
    (hotkey2) => hotkey2.name === action.payload.command
  );
  if (!hotkey)
    return;
  if (pluginCommands.current) {
    const command = pluginCommands.current.find(
      (command2) => command2.name === action.payload.command
    );
    if (command) {
      const defaultHotkeys = commandToHotkeys(command).hotkeys;
      const index = action.payload.primary ? 0 : 1;
      hotkey.hotkeys[index] = defaultHotkeys[index];
      const customHotkeys = state.customHotkeys[action.payload.command];
      if (customHotkeys)
        if (action.payload.primary) {
          delete customHotkeys.primary;
        } else {
          delete customHotkeys.secondary;
        }
    }
  }
};

// src/stores/hotkeys/reducers/update-conflicting-hotkeys.ts
var updateConflictingHotkeys = (state, action) => {
  const groupedByHotkey = /* @__PURE__ */ new Map();
  for (const pluginHotkey of state.hotkeys) {
    for (const hotkey of pluginHotkey.hotkeys) {
      delete hotkey.obsidianConflict;
      delete hotkey.pluginConflict;
      const conflict = action.payload.conflictingHotkeys.get(
        hotkey.string_representation
      );
      if (conflict) {
        hotkey.obsidianConflict = conflict;
      } else {
        let set = groupedByHotkey.get(hotkey.string_representation);
        if (!set) {
          set = /* @__PURE__ */ new Set();
          groupedByHotkey.set(hotkey.string_representation, set);
        }
        set.add(pluginHotkey);
      }
    }
  }
  const conflicting = [...groupedByHotkey.entries()].filter(
    (v) => v[1].size > 1
  );
  for (const [string_representation, hotkeys] of conflicting) {
    const conflicting2 = Array.from(hotkeys).map((h) => h.name).join(", ");
    for (const pluginHotkey of hotkeys) {
      for (const hotkey of pluginHotkey.hotkeys) {
        if (hotkey.string_representation === string_representation)
          hotkey.pluginConflict = conflicting2;
      }
    }
  }
};

// src/stores/hotkeys/hotkey-reducer.ts
var updateState = (state, action) => {
  if (action.type === "UI/SET_SEARCH_TERM") {
    state.searchTerm = action.payload.searchTerm.toLowerCase();
  } else if (action.type === "SETTINGS/LOAD_CUSTOM_HOTKEYS") {
    loadCustomHotkeys(state, action);
  } else if (action.type === "HOTKEY/UPDATE") {
    updateHotkey(state, action);
  } else if (action.type === "HOTKEY/RESET") {
    resetHotkey(state, action);
  } else if (action.type === "SET_CONFLICTING_HOTKEYS") {
    updateConflictingHotkeys(state, action);
  }
};
var hotkeyReducer = (store, action) => {
  updateState(store, action);
  return store;
};

// src/stores/hotkeys/hotkey-store.ts
var initialValue = {
  hotkeys: [],
  searchTerm: "",
  customHotkeys: {}
};
var hotkeyStore = new Store(
  initialValue,
  hotkeyReducer
);

// src/helpers/group-array-by-property.ts
var groupArrayByProperty = (array, property, grouped = {}) => {
  for (const item of array) {
    const key = String(item[property]);
    if (!grouped[key]) {
      grouped[key] = [];
    }
    grouped[key].push(item);
  }
  for (const key of Object.keys(grouped)) {
    if (grouped[key].length === 0) {
      delete grouped[key];
    }
  }
  return grouped;
};

// src/stores/hotkeys/derived/filtered-hotkeys.ts
var filteredHotkeys = derived(
  hotkeyStore,
  (store) => {
    let array = [];
    if (store.searchTerm) {
      array = store.hotkeys.filter((c) => {
        const fullName = hotkeysLang[c.name].toLowerCase();
        return fullName.includes(store.searchTerm) || c.group.toLowerCase().includes(store.searchTerm);
      });
    } else
      array = store.hotkeys;
    return groupArrayByProperty(array, "group", {
      "Create cards": [],
      "Edit cards": [],
      "Move cards": [],
      "Merge cards": [],
      "Delete cards": [],
      Navigation: [],
      history: [],
      search: []
    });
  },
  ["UI/SET_SEARCH_TERM", "SET_CONFLICTING_HOTKEYS"]
);

// src/view/components/container/hotkeys/components/hotkey/render-hotkey.svelte
function add_css2(target) {
  append_styles(target, "svelte-xx7tpf", ".hotkey-buttons.svelte-xx7tpf{width:100%;height:100%;position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;gap:5px;opacity:0;background-color:var(--color-base-70)}.hotkey-button.svelte-xx7tpf{border:none;width:16px;height:16px;box-shadow:none;padding:2px;cursor:pointer}.hotkey-buttons.svelte-xx7tpf:hover{opacity:0.8}.hotkey-key.svelte-xx7tpf{color:var(--text-on-accent);background-color:#175c5a}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let kbd;
  let t_value = (
    /*modifier*/
    ctx[2] + ""
  );
  let t;
  return {
    c() {
      kbd = element("kbd");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, kbd, anchor);
      append(kbd, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*hotkey*/
      2 && t_value !== (t_value = /*modifier*/
      ctx2[2] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(kbd);
      }
    }
  };
}
function create_fragment30(ctx) {
  let div;
  let button;
  let pen;
  let t0;
  let kbd;
  let t1_value = (
    /*hotkey*/
    ctx[1].key + ""
  );
  let t1;
  let t2;
  let each_1_anchor;
  let current;
  let mounted;
  let dispose;
  pen = new pen_default({ props: { class: "svg-icon", size: 8 } });
  let each_value = ensure_array_like(
    /*hotkey*/
    ctx[1].modifiers
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      create_component(pen.$$.fragment);
      t0 = space();
      kbd = element("kbd");
      t1 = text(t1_value);
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      attr(button, "class", "hotkey-button svelte-xx7tpf");
      attr(div, "class", "hotkey-buttons svelte-xx7tpf");
      attr(kbd, "class", "hotkey-key svelte-xx7tpf");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      mount_component(pen, button, null);
      insert(target, t0, anchor);
      insert(target, kbd, anchor);
      append(kbd, t1);
      insert(target, t2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*enableEditing*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & /*hotkey*/
      2) && t1_value !== (t1_value = /*hotkey*/
      ctx[1].key + ""))
        set_data(t1, t1_value);
      if (dirty & /*hotkey*/
      2) {
        each_value = ensure_array_like(
          /*hotkey*/
          ctx[1].modifiers
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(kbd);
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(pen);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { enableEditing } = $$props;
  let { hotkey } = $$props;
  $$self.$$set = ($$props2) => {
    if ("enableEditing" in $$props2)
      $$invalidate(0, enableEditing = $$props2.enableEditing);
    if ("hotkey" in $$props2)
      $$invalidate(1, hotkey = $$props2.hotkey);
  };
  return [enableEditing, hotkey];
}
var Render_hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment30, safe_not_equal, { enableEditing: 0, hotkey: 1 }, add_css2);
  }
};
var render_hotkey_default = Render_hotkey;

// src/view/actions/keyboard-shortcuts/helpers/commands/update-commands-dictionary.ts
var commandsDictionary = {
  current: {}
};
var updateCommandsDictionary = (pluginHotkeys) => {
  if (!pluginCommands.current)
    return;
  const dictByName = Object.fromEntries(
    pluginCommands.current.map((command) => [command.name, command])
  );
  commandsDictionary.current = {};
  for (const pluginHotkey of pluginHotkeys) {
    for (const hotkey of pluginHotkey.hotkeys) {
      commandsDictionary.current[hotkeyToString(hotkey)] = {
        ...dictByName[pluginHotkey.name],
        hotkeys: pluginHotkey.hotkeys
      };
    }
  }
};

// src/view/components/container/hotkeys/components/hotkey/edit-hotkey.svelte
function add_css3(target) {
  append_styles(target, "svelte-znv3dy", ".container.svelte-znv3dy{display:flex;gap:5px;align-items:center;justify-content:center}.hotkey-container.svelte-znv3dy{display:flex;flex-direction:column;align-items:center;gap:5px}.input.svelte-znv3dy{width:115px;height:25px;text-align:center;font-size:14px}.modifiers.svelte-znv3dy{display:flex;gap:5px;width:100%;justify-content:center}.disabled.svelte-znv3dy{background-color:var(--color-base-50)}.save-and-cancel-buttons.svelte-znv3dy{display:flex;gap:5px;flex-direction:column}.hotkey-button.svelte-znv3dy{background-color:transparent;color:var(--color-base-25);border:none;width:20px;height:20px;box-shadow:none;padding:2px;cursor:pointer}.hotkey-key.svelte-znv3dy{color:lightgrey;background-color:#175c5a;border-color:#227f7d\n    }");
}
function create_fragment31(ctx) {
  let div3;
  let div1;
  let div0;
  let kbd0;
  let t0_value = "Ctrl" /* Ctrl */ + "";
  let t0;
  let kbd0_class_value;
  let t1;
  let kbd1;
  let t2_value = "Alt" /* Alt */ + "";
  let t2;
  let kbd1_class_value;
  let t3;
  let kbd2;
  let t4_value = "Shift" /* Shift */ + "";
  let t4;
  let kbd2_class_value;
  let t5;
  let input;
  let input_placeholder_value;
  let t6;
  let div2;
  let button0;
  let rotateccw;
  let t7;
  let button1;
  let x;
  let current;
  let mounted;
  let dispose;
  rotateccw = new rotate_ccw_default({ props: { class: "svg-icon", size: 8 } });
  x = new x_default({ props: { class: "svg-icon", size: 8 } });
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      kbd0 = element("kbd");
      t0 = text(t0_value);
      t1 = space();
      kbd1 = element("kbd");
      t2 = text(t2_value);
      t3 = space();
      kbd2 = element("kbd");
      t4 = text(t4_value);
      t5 = space();
      input = element("input");
      t6 = space();
      div2 = element("div");
      button0 = element("button");
      create_component(rotateccw.$$.fragment);
      t7 = space();
      button1 = element("button");
      create_component(x.$$.fragment);
      attr(kbd0, "class", kbd0_class_value = null_to_empty(!/*CTRL*/
      ctx[2] ? "disabled" : "") + " svelte-znv3dy");
      attr(kbd1, "class", kbd1_class_value = null_to_empty(!/*ALT*/
      ctx[4] ? "disabled" : "") + " svelte-znv3dy");
      attr(kbd2, "class", kbd2_class_value = null_to_empty(!/*SHIFT*/
      ctx[3] ? "disabled" : "") + " svelte-znv3dy");
      attr(div0, "class", "modifiers svelte-znv3dy");
      attr(input, "class", "search-input input hotkey-key svelte-znv3dy");
      attr(input, "placeholder", input_placeholder_value = "Key");
      attr(input, "spellcheck", "false");
      attr(input, "type", "text");
      attr(div1, "class", "hotkey-container svelte-znv3dy");
      attr(button0, "aria-label", "Reset");
      attr(button0, "class", "hotkey-button svelte-znv3dy");
      attr(button1, "aria-label", "Go back");
      attr(button1, "class", "hotkey-button svelte-znv3dy");
      attr(div2, "class", "save-and-cancel-buttons svelte-znv3dy");
      attr(div3, "class", "container svelte-znv3dy");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div0, kbd0);
      append(kbd0, t0);
      append(div0, t1);
      append(div0, kbd1);
      append(kbd1, t2);
      append(div0, t3);
      append(div0, kbd2);
      append(kbd2, t4);
      append(div1, t5);
      append(div1, input);
      set_input_value(
        input,
        /*key*/
        ctx[1]
      );
      append(div3, t6);
      append(div3, div2);
      append(div2, button0);
      mount_component(rotateccw, button0, null);
      append(div2, t7);
      append(div2, button1);
      mount_component(x, button1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            kbd0,
            "click",
            /*toggleCtrl*/
            ctx[6]
          ),
          listen(
            kbd1,
            "click",
            /*toggleAlt*/
            ctx[8]
          ),
          listen(
            kbd2,
            "click",
            /*toggleShift*/
            ctx[7]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[13]
          ),
          listen(
            input,
            "keydown",
            /*onKeyDown*/
            ctx[5]
          ),
          listen(
            button0,
            "click",
            /*reset*/
            ctx[9]
          ),
          listen(button1, "click", function() {
            if (is_function(
              /*onCancel*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*CTRL*/
      4 && kbd0_class_value !== (kbd0_class_value = null_to_empty(!/*CTRL*/
      ctx[2] ? "disabled" : "") + " svelte-znv3dy")) {
        attr(kbd0, "class", kbd0_class_value);
      }
      if (!current || dirty & /*ALT*/
      16 && kbd1_class_value !== (kbd1_class_value = null_to_empty(!/*ALT*/
      ctx[4] ? "disabled" : "") + " svelte-znv3dy")) {
        attr(kbd1, "class", kbd1_class_value);
      }
      if (!current || dirty & /*SHIFT*/
      8 && kbd2_class_value !== (kbd2_class_value = null_to_empty(!/*SHIFT*/
      ctx[3] ? "disabled" : "") + " svelte-znv3dy")) {
        attr(kbd2, "class", kbd2_class_value);
      }
      if (dirty & /*key*/
      2 && input.value !== /*key*/
      ctx[1]) {
        set_input_value(
          input,
          /*key*/
          ctx[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rotateccw.$$.fragment, local);
      transition_in(x.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rotateccw.$$.fragment, local);
      transition_out(x.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(rotateccw);
      destroy_component(x);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance31($$self, $$props, $$invalidate) {
  let { hotkey } = $$props;
  let { commandName } = $$props;
  let { isPrimary } = $$props;
  let { onCancel } = $$props;
  let key = hotkey.key;
  let CTRL = hotkey.modifiers.includes("Ctrl");
  let SHIFT = hotkey.modifiers.includes("Shift");
  let ALT = hotkey.modifiers.includes("Alt");
  const onKeyDown = (e) => {
    e.preventDefault();
    if (e.shiftKey || e.ctrlKey || e.altKey)
      return;
    if (e.key === " " || e.key === "META")
      return;
    const value = e.key.toUpperCase();
    $$invalidate(1, key = value.length === 1 ? value.toUpperCase() : value);
    save();
  };
  const toggleCtrl = () => {
    $$invalidate(2, CTRL = !CTRL);
    save();
  };
  const toggleShift = () => {
    $$invalidate(3, SHIFT = !SHIFT);
    save();
  };
  const toggleAlt = () => {
    $$invalidate(4, ALT = !ALT);
    save();
  };
  const save = () => {
    let modifiers = [];
    if (CTRL)
      modifiers.push("Ctrl");
    if (SHIFT)
      modifiers.push("Shift");
    if (ALT)
      modifiers.push("Alt");
    hotkeyStore.dispatch({
      type: "HOTKEY/UPDATE",
      payload: {
        hotkey: { key, modifiers },
        primary: isPrimary,
        command: commandName
      }
    });
  };
  const reset = () => {
    hotkeyStore.dispatch({
      type: "HOTKEY/RESET",
      payload: { command: commandName, primary: isPrimary }
    });
    setTimeout(() => {
      $$invalidate(2, CTRL = hotkey.modifiers.includes("Ctrl"));
      $$invalidate(4, ALT = hotkey.modifiers.includes("Alt"));
      $$invalidate(3, SHIFT = hotkey.modifiers.includes("Shift"));
      $$invalidate(1, key = hotkey.key);
    });
  };
  function input_input_handler() {
    key = this.value;
    $$invalidate(1, key);
  }
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(10, hotkey = $$props2.hotkey);
    if ("commandName" in $$props2)
      $$invalidate(11, commandName = $$props2.commandName);
    if ("isPrimary" in $$props2)
      $$invalidate(12, isPrimary = $$props2.isPrimary);
    if ("onCancel" in $$props2)
      $$invalidate(0, onCancel = $$props2.onCancel);
  };
  return [
    onCancel,
    key,
    CTRL,
    SHIFT,
    ALT,
    onKeyDown,
    toggleCtrl,
    toggleShift,
    toggleAlt,
    reset,
    hotkey,
    commandName,
    isPrimary,
    input_input_handler
  ];
}
var Edit_hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance31,
      create_fragment31,
      safe_not_equal,
      {
        hotkey: 10,
        commandName: 11,
        isPrimary: 12,
        onCancel: 0
      },
      add_css3
    );
  }
};
var edit_hotkey_default = Edit_hotkey;

// src/view/components/container/hotkeys/components/hotkey/hotkey.svelte
var import_classnames = __toESM(require_classnames());
function add_css4(target) {
  append_styles(target, "svelte-m6btx5", ".hotkey.svelte-m6btx5{padding:5px;background-color:var(--color-base-50);display:flex;gap:5px;border-radius:3px;width:fit-content;position:relative}.editing.svelte-m6btx5{background-color:var(--color-base-60)}.obsidian-conflict.svelte-m6btx5{background-color:var(--color-red)}.plugin-conflict.svelte-m6btx5{background-color:var(--color-orange)}");
}
function create_else_block(ctx) {
  let renderhotkey;
  let current;
  renderhotkey = new render_hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[0]
      ),
      enableEditing: (
        /*func_1*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(renderhotkey.$$.fragment);
    },
    m(target, anchor) {
      mount_component(renderhotkey, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const renderhotkey_changes = {};
      if (dirty & /*hotkey*/
      1)
        renderhotkey_changes.hotkey = /*hotkey*/
        ctx2[0];
      if (dirty & /*editing*/
      8)
        renderhotkey_changes.enableEditing = /*func_1*/
        ctx2[5];
      renderhotkey.$set(renderhotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(renderhotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(renderhotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(renderhotkey, detaching);
    }
  };
}
function create_if_block(ctx) {
  let edithotkey;
  let current;
  edithotkey = new edit_hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[0]
      ),
      onCancel: (
        /*func*/
        ctx[4]
      ),
      isPrimary: (
        /*isPrimary*/
        ctx[2]
      ),
      commandName: (
        /*commandName*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(edithotkey.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edithotkey, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edithotkey_changes = {};
      if (dirty & /*hotkey*/
      1)
        edithotkey_changes.hotkey = /*hotkey*/
        ctx2[0];
      if (dirty & /*editing*/
      8)
        edithotkey_changes.onCancel = /*func*/
        ctx2[4];
      if (dirty & /*isPrimary*/
      4)
        edithotkey_changes.isPrimary = /*isPrimary*/
        ctx2[2];
      if (dirty & /*commandName*/
      2)
        edithotkey_changes.commandName = /*commandName*/
        ctx2[1];
      edithotkey.$set(edithotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edithotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edithotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edithotkey, detaching);
    }
  };
}
function create_fragment32(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_aria_label_value;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*editing*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "aria-label", div_aria_label_value = /*hotkey*/
      ctx[0].obsidianConflict ? `Used by "${/*hotkey*/
      ctx[0].obsidianConflict}"` : (
        /*hotkey*/
        ctx[0].pluginConflict ? `Used by "${/*hotkey*/
        ctx[0].pluginConflict}"` : ""
      ));
      attr(div, "class", div_class_value = null_to_empty((0, import_classnames.default)(
        "hotkey",
        /*hotkey*/
        ctx[0].obsidianConflict && "obsidian-conflict",
        /*hotkey*/
        ctx[0].pluginConflict && "plugin-conflict",
        /*editing*/
        ctx[3] && "editing"
      )) + " svelte-m6btx5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*hotkey*/
      1 && div_aria_label_value !== (div_aria_label_value = /*hotkey*/
      ctx2[0].obsidianConflict ? `Used by "${/*hotkey*/
      ctx2[0].obsidianConflict}"` : (
        /*hotkey*/
        ctx2[0].pluginConflict ? `Used by "${/*hotkey*/
        ctx2[0].pluginConflict}"` : ""
      ))) {
        attr(div, "aria-label", div_aria_label_value);
      }
      if (!current || dirty & /*hotkey, editing*/
      9 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames.default)(
        "hotkey",
        /*hotkey*/
        ctx2[0].obsidianConflict && "obsidian-conflict",
        /*hotkey*/
        ctx2[0].pluginConflict && "plugin-conflict",
        /*editing*/
        ctx2[3] && "editing"
      )) + " svelte-m6btx5")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance32($$self, $$props, $$invalidate) {
  let { hotkey } = $$props;
  let { commandName } = $$props;
  let { isPrimary } = $$props;
  let editing = false;
  const func2 = () => $$invalidate(3, editing = false);
  const func_1 = () => $$invalidate(3, editing = true);
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
    if ("commandName" in $$props2)
      $$invalidate(1, commandName = $$props2.commandName);
    if ("isPrimary" in $$props2)
      $$invalidate(2, isPrimary = $$props2.isPrimary);
  };
  return [hotkey, commandName, isPrimary, editing, func2, func_1];
}
var Hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment32, safe_not_equal, { hotkey: 0, commandName: 1, isPrimary: 2 }, add_css4);
  }
};
var hotkey_default = Hotkey;

// src/view/components/container/hotkeys/components/command.svelte
function add_css5(target) {
  append_styles(target, "svelte-1gi600y", ".command.svelte-1gi600y{padding:8px;display:flex;align-items:center;justify-content:space-between;border-radius:4px;gap:8px;background-color:var(--color-base-30)}.hotkeys.svelte-1gi600y{display:flex;flex-direction:column;align-items:end;gap:5px}.label.svelte-1gi600y{font-size:14px;color:var(--text-normal);display:block}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  child_ctx[3] = i;
  return child_ctx;
}
function create_each_block3(ctx) {
  let hotkey_1;
  let current;
  hotkey_1 = new hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[1]
      ),
      commandName: (
        /*commandHotkeys*/
        ctx[0].name
      ),
      isPrimary: (
        /*i*/
        ctx[3] === 0
      )
    }
  });
  return {
    c() {
      create_component(hotkey_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkey_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const hotkey_1_changes = {};
      if (dirty & /*commandHotkeys*/
      1)
        hotkey_1_changes.hotkey = /*hotkey*/
        ctx2[1];
      if (dirty & /*commandHotkeys*/
      1)
        hotkey_1_changes.commandName = /*commandHotkeys*/
        ctx2[0].name;
      hotkey_1.$set(hotkey_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkey_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkey_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkey_1, detaching);
    }
  };
}
function create_fragment33(ctx) {
  let div1;
  let span;
  let t0_value = hotkeysLang[
    /*commandHotkeys*/
    ctx[0].name
  ] + "";
  let t0;
  let t1;
  let div0;
  let current;
  let each_value = ensure_array_like(
    /*commandHotkeys*/
    ctx[0].hotkeys
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "label svelte-1gi600y");
      attr(div0, "class", "hotkeys svelte-1gi600y");
      attr(div1, "class", "command svelte-1gi600y");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      append(span, t0);
      append(div1, t1);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*commandHotkeys*/
      1) && t0_value !== (t0_value = hotkeysLang[
        /*commandHotkeys*/
        ctx2[0].name
      ] + ""))
        set_data(t0, t0_value);
      if (dirty & /*commandHotkeys*/
      1) {
        each_value = ensure_array_like(
          /*commandHotkeys*/
          ctx2[0].hotkeys
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { commandHotkeys } = $$props;
  $$self.$$set = ($$props2) => {
    if ("commandHotkeys" in $$props2)
      $$invalidate(0, commandHotkeys = $$props2.commandHotkeys);
  };
  return [commandHotkeys];
}
var Command = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance33, create_fragment33, safe_not_equal, { commandHotkeys: 0 }, add_css5);
  }
};
var command_default = Command;

// src/view/components/container/hotkeys/group.svelte
function add_css6(target) {
  append_styles(target, "svelte-1odqylp", ".group.svelte-1odqylp{background-color:var(--background-secondary);padding:var(--size-4-2);border-radius:3px}.hotkeys-list.svelte-1odqylp{display:flex;flex-direction:column;gap:var(--size-4-2);overflow-y:auto}.group-name.svelte-1odqylp{padding-bottom:10px;padding-left:5px;font-size:16px;color:var(--color-base-70)}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block4(key_1, ctx) {
  let first;
  let hotkey;
  let current;
  hotkey = new command_default({
    props: {
      commandHotkeys: (
        /*commandHotkeys*/
        ctx[2]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(hotkey.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(hotkey, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const hotkey_changes = {};
      if (dirty & /*group*/
      1)
        hotkey_changes.commandHotkeys = /*commandHotkeys*/
        ctx[2];
      hotkey.$set(hotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(hotkey, detaching);
    }
  };
}
function create_fragment34(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*group*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*commandHotkeys*/
    ctx2[2].name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*groupName*/
        ctx[1]
      );
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "group-name svelte-1odqylp");
      attr(div1, "class", "hotkeys-list svelte-1odqylp");
      attr(div2, "class", "group svelte-1odqylp");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*groupName*/
      2)
        set_data(
          t0,
          /*groupName*/
          ctx2[1]
        );
      if (dirty & /*group*/
      1) {
        each_value = ensure_array_like(
          /*group*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block4, null, get_each_context4);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let { group } = $$props;
  let { groupName } = $$props;
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group = $$props2.group);
    if ("groupName" in $$props2)
      $$invalidate(1, groupName = $$props2.groupName);
  };
  return [group, groupName];
}
var Group = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment34, safe_not_equal, { group: 0, groupName: 1 }, add_css6);
  }
};
var group_default = Group;

// src/view/components/container/hotkeys/front.svelte
function add_css7(target) {
  append_styles(target, "svelte-errn56", ".front.svelte-errn56{display:flex;justify-content:space-between;align-items:center;width:100%;padding:0 var(--size-4-2)}.search-input-container.svelte-errn56{width:100%}");
}
function create_fragment35(ctx) {
  let div2;
  let div1;
  let input;
  let input_placeholder_value;
  let t;
  let div0;
  let div0_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "class", "search-input");
      attr(input, "enterkeyhint", "search");
      attr(input, "placeholder", input_placeholder_value = "Filter");
      attr(input, "spellcheck", "false");
      attr(input, "type", "search");
      attr(div0, "aria-label", div0_aria_label_value = "Clear");
      attr(div0, "class", "search-input-clear-button");
      attr(div1, "class", "search-input-container svelte-errn56");
      attr(div2, "class", "front svelte-errn56");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, input);
      set_input_value(
        input,
        /*searchTerm*/
        ctx[0]
      );
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[1]
          ),
          listen(
            div0,
            "click",
            /*click_handler*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*searchTerm*/
      1 && input.value !== /*searchTerm*/
      ctx2[0]) {
        set_input_value(
          input,
          /*searchTerm*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance35($$self, $$props, $$invalidate) {
  let searchTerm = "";
  function input_input_handler() {
    searchTerm = this.value;
    $$invalidate(0, searchTerm);
  }
  const click_handler = () => {
    $$invalidate(0, searchTerm = "");
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*searchTerm*/
    1) {
      $: {
        hotkeyStore.dispatch({
          type: "UI/SET_SEARCH_TERM",
          payload: { searchTerm }
        });
      }
    }
  };
  return [searchTerm, input_input_handler, click_handler];
}
var Front = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment35, safe_not_equal, {}, add_css7);
  }
};
var front_default = Front;

// src/view/components/container/hotkeys/hotkeys.svelte
function add_css8(target) {
  append_styles(target, "svelte-10o9ca", ".sidebar.svelte-10o9ca{width:350px;background-color:var(--background-primary);position:absolute;right:var(--sidebar-right);top:var(--size-4-2);padding:var(--size-4-2) 0;display:flex;flex-direction:column;gap:var(--size-4-2)\n    }.groups.svelte-10o9ca{padding:0 var(--size-4-2);display:flex;flex-direction:column;gap:var(--size-4-2);max-height:400px;overflow-y:auto}.note.svelte-10o9ca{font-size:12px;color:var(--color-base-40);padding:var(--size-4-2)}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i][0];
  child_ctx[2] = list[i][1];
  return child_ctx;
}
function create_each_block5(key_1, ctx) {
  let first;
  let group_1;
  let current;
  group_1 = new group_default({
    props: {
      groupName: (
        /*groupName*/
        ctx[1]
      ),
      group: (
        /*group*/
        ctx[2]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(group_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(group_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const group_1_changes = {};
      if (dirty & /*$filteredHotkeys*/
      1)
        group_1_changes.groupName = /*groupName*/
        ctx[1];
      if (dirty & /*$filteredHotkeys*/
      1)
        group_1_changes.group = /*group*/
        ctx[2];
      group_1.$set(group_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(group_1, detaching);
    }
  };
}
function create_fragment36(ctx) {
  let div2;
  let front;
  let t0;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div1;
  let current;
  front = new front_default({});
  let each_value = ensure_array_like(Object.entries(
    /*$filteredHotkeys*/
    ctx[0]
  ));
  const get_key = (ctx2) => (
    /*groupName*/
    ctx2[1]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block5(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      create_component(front.$$.fragment);
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div1 = element("div");
      div1.textContent = "*If a keyboard shortcut is not working, make sure it is not assigned to\n        an Obsidian command.";
      attr(div0, "class", "groups svelte-10o9ca");
      attr(div1, "class", "note svelte-10o9ca");
      attr(div2, "class", "sidebar svelte-10o9ca");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(front, div2, null);
      append(div2, t0);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t1);
      append(div2, div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object, $filteredHotkeys*/
      1) {
        each_value = ensure_array_like(Object.entries(
          /*$filteredHotkeys*/
          ctx2[0]
        ));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block5, null, get_each_context5);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(front.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(front.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(front);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let $filteredHotkeys;
  component_subscribe($$self, filteredHotkeys, ($$value) => $$invalidate(0, $filteredHotkeys = $$value));
  return [$filteredHotkeys];
}
var Hotkeys = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment36, safe_not_equal, {}, add_css8);
  }
};
var hotkeys_default = Hotkeys;

// src/helpers/relative-time.ts
var rtf1 = new Intl.RelativeTimeFormat("en", { style: "long" });
var relativeTime = (updated) => {
  const difference = Date.now() - updated;
  const days = Math.floor(difference / (1e3 * 60 * 60 * 24));
  const hours = Math.floor(difference / (1e3 * 60 * 60));
  const minutes = Math.floor(difference / (1e3 * 60));
  let relativeTime2;
  if (days > 0) {
    relativeTime2 = rtf1.format(-days, "day");
  } else if (hours > 0) {
    relativeTime2 = rtf1.format(-hours, "hour");
  } else if (minutes > 0) {
    relativeTime2 = rtf1.format(-minutes, "minute");
  } else {
    relativeTime2 = "Just now";
  }
  return relativeTime2;
};

// src/view/components/container/file-history/components/helpers/action-info.ts
var actionInfo = {
  "DOCUMENT/SET_NODE_CONTENT": { label: "Updated a node", icon: file_pen_default },
  "DOCUMENT/INSERT_NODE": { label: "Created a node", icon: file_plus_default },
  "DOCUMENT/DROP_NODE": { label: "Dropped a node", icon: file_output_default },
  "DOCUMENT/LOAD_FILE": { label: "Loaded document", icon: file_up_default },
  "DOCUMENT/DELETE_NODE": { label: "Deleted a node", icon: file_minus_default },
  "DOCUMENT/MOVE_NODE": { label: "Moved a node", icon: file_output_default },
  "DOCUMENT/MERGE_NODE": { label: "Merged a node", icon: merge_default }
};

// src/view/components/container/file-history/components/snapshot-button.svelte
var import_obsidian2 = require("obsidian");
function add_css9(target) {
  append_styles(target, "svelte-1f3mh24", ".snapshot.svelte-1f3mh24{padding:8px 4px;cursor:pointer;display:flex;align-items:center;border-radius:4px;gap:8px}.index.svelte-1f3mh24{font-size:12px;color:var(--color-base-50);min-width:16px;text-align:left;margin-left:auto}.selected.svelte-1f3mh24{background-color:var(--nav-item-background-selected)}.time.svelte-1f3mh24{font-size:12px;color:var(--color-base-60)}");
}
function create_fragment37(ctx) {
  let div;
  let switch_instance;
  let t0;
  let span0;
  let t1_value = relativeTime(
    /*snapshot*/
    ctx[0].created
  ) + "";
  let t1;
  let span0_data_created_value;
  let t2;
  let span1;
  let t3;
  let div_aria_label_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*icon*/
    ctx[6].icon
  );
  function switch_props(ctx2, dirty) {
    return { props: { class: "svg-icon label" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      span1 = element("span");
      t3 = text(
        /*reverseIndex*/
        ctx[2]
      );
      attr(span0, "class", "time svelte-1f3mh24");
      attr(span0, "data-created", span0_data_created_value = /*snapshot*/
      ctx[0].created);
      attr(span1, "class", "index svelte-1f3mh24");
      attr(div, "aria-label", div_aria_label_value = /*icon*/
      ctx[6].label);
      attr(div, "class", "snapshot svelte-1f3mh24");
      toggle_class(
        div,
        "selected",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t0);
      append(div, span0);
      append(span0, t1);
      append(div, t2);
      append(div, span1);
      append(span1, t3);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = /*icon*/
      ctx2[6].icon)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t0);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if ((!current || dirty & /*snapshot*/
      1) && t1_value !== (t1_value = relativeTime(
        /*snapshot*/
        ctx2[0].created
      ) + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*snapshot*/
      1 && span0_data_created_value !== (span0_data_created_value = /*snapshot*/
      ctx2[0].created)) {
        attr(span0, "data-created", span0_data_created_value);
      }
      if (!current || dirty & /*reverseIndex*/
      4)
        set_data(
          t3,
          /*reverseIndex*/
          ctx2[2]
        );
      if (!current || dirty & /*active*/
      2) {
        toggle_class(
          div,
          "selected",
          /*active*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
}
function instance37($$self, $$props, $$invalidate) {
  let { snapshot } = $$props;
  let { active } = $$props;
  let { reverseIndex } = $$props;
  let { filePath } = $$props;
  const view = getView();
  const documentStore = view.documentStore;
  const viewStore = view.viewStore;
  const icon = actionInfo[snapshot.action.type] ? actionInfo[snapshot.action.type] : {
    label: snapshot.action.type || "unknown",
    icon: file_question_default
  };
  const click_handler = () => {
    if (viewStore.getValue().document.editing.activeNodeId)
      new import_obsidian2.Notice("cannot apply snapshot while editing");
    else
      documentStore.dispatch({
        type: "HISTORY/SELECT_SNAPSHOT",
        payload: { snapshotId: snapshot.id, path: filePath }
      });
  };
  $$self.$$set = ($$props2) => {
    if ("snapshot" in $$props2)
      $$invalidate(0, snapshot = $$props2.snapshot);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
    if ("reverseIndex" in $$props2)
      $$invalidate(2, reverseIndex = $$props2.reverseIndex);
    if ("filePath" in $$props2)
      $$invalidate(3, filePath = $$props2.filePath);
  };
  return [
    snapshot,
    active,
    reverseIndex,
    filePath,
    documentStore,
    viewStore,
    icon,
    click_handler
  ];
}
var Snapshot_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance37,
      create_fragment37,
      safe_not_equal,
      {
        snapshot: 0,
        active: 1,
        reverseIndex: 2,
        filePath: 3
      },
      add_css9
    );
  }
};
var snapshot_button_default = Snapshot_button;

// src/view/actions/update-relative-time.ts
var updateRelativeTime = (element2) => {
  const interval = setInterval(() => {
    const children2 = Array.from(
      element2.querySelectorAll("[data-created]")
    );
    for (const child of children2) {
      const created = child.dataset["created"];
      if (created && !isNaN(+created))
        child.textContent = relativeTime(+created);
    }
  }, 30 * 1e3);
  return {
    destroy: () => {
      clearInterval(interval);
    }
  };
};

// src/view/components/container/file-history/file-histoy.svelte
function add_css10(target) {
  append_styles(target, "svelte-asujsp", ".sidebar.svelte-asujsp{min-width:165px;width:fit-content;background-color:var(--background-secondary);position:absolute;right:var(--sidebar-right);top:var(--size-4-2);padding:var(--size-4-2)}.snapshots-list.svelte-asujsp{display:flex;flex-direction:column;gap:5px;max-height:200px;overflow-y:auto}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  child_ctx[4] = i;
  return child_ctx;
}
function create_each_block6(key_1, ctx) {
  let first;
  let snapshotbutton;
  let current;
  snapshotbutton = new snapshot_button_default({
    props: {
      snapshot: (
        /*snapshot*/
        ctx[2]
      ),
      active: (
        /*documentHistory*/
        ctx[0].items.length - /*index*/
        ctx[4] - 1 === /*documentHistory*/
        ctx[0].state.activeIndex
      ),
      filePath: (
        /*path*/
        ctx[1]
      ),
      reverseIndex: (
        /*documentHistory*/
        ctx[0].items.length - /*index*/
        ctx[4]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(snapshotbutton.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(snapshotbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const snapshotbutton_changes = {};
      if (dirty & /*documentHistory*/
      1)
        snapshotbutton_changes.snapshot = /*snapshot*/
        ctx[2];
      if (dirty & /*documentHistory*/
      1)
        snapshotbutton_changes.active = /*documentHistory*/
        ctx[0].items.length - /*index*/
        ctx[4] - 1 === /*documentHistory*/
        ctx[0].state.activeIndex;
      if (dirty & /*path*/
      2)
        snapshotbutton_changes.filePath = /*path*/
        ctx[1];
      if (dirty & /*documentHistory*/
      1)
        snapshotbutton_changes.reverseIndex = /*documentHistory*/
        ctx[0].items.length - /*index*/
        ctx[4];
      snapshotbutton.$set(snapshotbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(snapshotbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(snapshotbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(snapshotbutton, detaching);
    }
  };
}
function create_fragment38(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let updateRelativeTime_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like([.../*documentHistory*/
  ctx[0].items].sort(func));
  const get_key = (ctx2) => (
    /*snapshot*/
    ctx2[2].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block6(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "snapshots-list svelte-asujsp");
      attr(div1, "class", "sidebar svelte-asujsp");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(updateRelativeTime_action = updateRelativeTime.call(null, div0));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*documentHistory, path*/
      3) {
        each_value = ensure_array_like([.../*documentHistory*/
        ctx2[0].items].sort(func));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block6, null, get_each_context6);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
var func = (a, b) => b.created - a.created;
function instance38($$self, $$props, $$invalidate) {
  let { documentHistory } = $$props;
  let { path } = $$props;
  $$self.$$set = ($$props2) => {
    if ("documentHistory" in $$props2)
      $$invalidate(0, documentHistory = $$props2.documentHistory);
    if ("path" in $$props2)
      $$invalidate(1, path = $$props2.path);
  };
  return [documentHistory, path];
}
var File_histoy = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance38, create_fragment38, safe_not_equal, { documentHistory: 0, path: 1 }, add_css10);
  }
};
var file_histoy_default = File_histoy;

// src/stores/view/helpers/search/traverse-down.ts
var traverseDown = (childGroups, columns, nodeId, columnIndex = 0) => {
  for (let i = columnIndex; i < columns.length; i++) {
    const column = columns[i];
    for (const group of column.groups) {
      if (group.parentId === nodeId) {
        if (!nodeId.startsWith("-r"))
          childGroups.push(nodeId);
        for (const childNodeId of group.nodes) {
          traverseDown(
            childGroups,
            columns,
            childNodeId,
            columnIndex + 1
          );
        }
      }
    }
  }
};

// src/view/actions/dnd/draggable.ts
var toggleDraggedNodeVisibility = (node, data, visible) => {
  requestAnimationFrame(() => {
    const parent = node.matchParent("#" + data.id);
    if (parent) {
      parent.style.display = visible ? "flex" : "none";
    }
  });
};
var draggable = (node, data) => {
  node.draggable = true;
  const handleDragstart = (event) => {
    if (!event.dataTransfer)
      return;
    const target = event.currentTarget;
    if (event.clientX - target.getBoundingClientRect().x <= 5 || target.dataset["test"] === "true") {
      event.dataTransfer.setData("text/plain", data.id);
      setTimeout(() => {
        const childGroups = [];
        traverseDown(
          childGroups,
          data.documentStore.getValue().document.columns,
          data.id
        );
        data.viewStore.dispatch({
          type: "SET_DRAG_STARTED",
          payload: { nodeId: data.id, childGroups }
        });
        toggleDraggedNodeVisibility(node, data, false);
      }, 0);
    } else {
      event.preventDefault();
    }
  };
  node.addEventListener("dragstart", handleDragstart);
  const handleDragEnd = () => {
    data.viewStore.dispatch({ type: "DOCUMENT/SET_DRAG_ENDED" });
    toggleDraggedNodeVisibility(node, data, true);
  };
  node.addEventListener("dragend", handleDragEnd);
  return {
    destroy: () => {
      node.removeEventListener("dragstart", handleDragstart);
      node.removeEventListener("dragend", handleDragEnd);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/dnd/draggable.svelte
function add_css11(target) {
  append_styles(target, "svelte-1n080qk", ".draggable.svelte-1n080qk.svelte-1n080qk{width:100%;background-color:transparent;display:flex;position:relative}.drag-handle.svelte-1n080qk.svelte-1n080qk{height:100%;width:6px;background-color:transparent;cursor:grab;position:absolute;left:0;z-index:1}.draggable.svelte-1n080qk:hover .drag-handle.svelte-1n080qk{background-size:2px 4px;background-image:linear-gradient(\n            0deg,\n            hsla(0, 0%, 44.7%, 0.25) 20%,\n            transparent 40%\n        )}");
}
function create_fragment39(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let draggable_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "drag-handle svelte-1n080qk");
      attr(div1, "class", "content");
      attr(div2, "class", "draggable svelte-1n080qk");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "dblclick",
            /*dblclick_handler*/
            ctx[5]
          ),
          action_destroyer(draggable_action = draggable.call(null, div2, {
            id: (
              /*nodeId*/
              ctx[0]
            ),
            documentStore: (
              /*documentStore*/
              ctx[1]
            ),
            viewStore: (
              /*viewStore*/
              ctx[2]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (draggable_action && is_function(draggable_action.update) && dirty & /*nodeId*/
      1)
        draggable_action.update.call(null, {
          id: (
            /*nodeId*/
            ctx2[0]
          ),
          documentStore: (
            /*documentStore*/
            ctx2[1]
          ),
          viewStore: (
            /*viewStore*/
            ctx2[2]
          )
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { nodeId } = $$props;
  const view = getView();
  const documentStore = view.documentStore;
  const viewStore = view.viewStore;
  const dblclick_handler = () => {
    viewStore.dispatch({
      type: "DOCUMENT/ENABLE_EDIT_MODE",
      payload: { nodeId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [nodeId, documentStore, viewStore, $$scope, slots, dblclick_handler];
}
var Draggable = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance39, create_fragment39, safe_not_equal, { nodeId: 0 }, add_css11);
  }
};
var draggable_default = Draggable;

// src/view/actions/dnd/droppable.ts
var getDropPosition = (event, targetElement) => {
  const boundingBox = targetElement.getBoundingClientRect();
  const mouseX = event.clientX;
  const mouseY = event.clientY;
  if (mouseY - boundingBox.top < boundingBox.height / 4) {
    return "up";
  } else if (boundingBox.bottom - mouseY < boundingBox.height / 4)
    return "down";
  else if (boundingBox.right - mouseX < boundingBox.width / 4)
    return "right";
};
var dropClasses = {
  up: "lineage__drop-node-above",
  down: "lineage__drop-node-below",
  right: "lineage__drop-node-under"
};
var classesList = Object.values(dropClasses);
var droppable = (node, { documentStore, viewStore }) => {
  function HandleDragLeave(event) {
    if (!(event.currentTarget instanceof HTMLElement))
      return;
    event.currentTarget.removeClasses(classesList);
    event.currentTarget.removeClass("inactive-node-hover");
  }
  const handleDragOver = (event) => {
    event.preventDefault();
    if (!event.dataTransfer)
      return;
    const targetCard = event.currentTarget;
    if (!targetCard.id.startsWith("n"))
      return;
    event.dataTransfer.dropEffect = "move";
    const position = getDropPosition(event, targetCard);
    targetCard.removeClasses(classesList);
    if (position) {
      targetCard.addClass(dropClasses[position]);
      if (targetCard.hasClass("inactive-node"))
        targetCard.addClass("inactive-node-hover");
    }
  };
  function handleDrop(event) {
    event.preventDefault();
    if (!(event.currentTarget instanceof HTMLElement))
      return;
    if (!event.dataTransfer)
      return;
    const data = event.dataTransfer.getData("text/plain");
    const targetCard = event.currentTarget;
    if (!targetCard.id.startsWith("n"))
      return;
    targetCard.removeClasses(classesList);
    targetCard.removeClass("inactive-node-hover");
    if (!data)
      throw new Error(`droppedNodeId is missing`);
    if (!targetCard.id)
      throw new Error(`targetCard.id is missing`);
    documentStore.dispatch({
      type: "DOCUMENT/DROP_NODE",
      payload: {
        droppedNodeId: data,
        targetNodeId: targetCard.id,
        position: getDropPosition(event, targetCard)
      }
    });
    viewStore.dispatch({
      type: "DOCUMENT/SET_DRAG_ENDED"
    });
  }
  node.addEventListener("dragleave", HandleDragLeave);
  node.addEventListener("dragover", handleDragOver);
  node.addEventListener("drop", handleDrop);
  return {
    destroy() {
      node.removeEventListener("dragleave", HandleDragLeave);
      node.removeEventListener("dragover", handleDragOver);
      node.removeEventListener("drop", handleDrop);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/bridges/bridges.svelte
function add_css12(target) {
  append_styles(target, "svelte-aqw235", ".active-node-bridge.svelte-aqw235,.active-parent-bridge-right.svelte-aqw235,.active-parent-bridge-left.svelte-aqw235{height:100%;width:10px;position:absolute;top:0}.active-parent-bridge-right.svelte-aqw235{right:-10px;background-color:var(--background-active-parent)}.active-parent-bridge-left.svelte-aqw235{left:-10px;background-color:var(--background-active-parent)}.active-node-bridge.svelte-aqw235{right:-10px;background-color:var(--background-active-node)}");
}
function create_if_block_1(ctx) {
  let div;
  let div_class_value;
  let t;
  let show_if = !/*parentId*/
  ctx[3].startsWith("r");
  let if_block_anchor;
  let if_block = show_if && create_if_block_2(ctx);
  return {
    c() {
      div = element("div");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div, "class", div_class_value = null_to_empty("active-parent-bridge-right") + " svelte-aqw235");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*parentId*/
      8)
        show_if = !/*parentId*/
        ctx2[3].startsWith("r");
      if (show_if) {
        if (if_block) {
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "active-node-bridge svelte-aqw235");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "active-parent-bridge-left svelte-aqw235");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment40(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!/*editing*/
    ctx2[0] && /*hasChildren*/
    ctx2[1] && /*active*/
    ctx2[2] === "node" /* node */)
      return create_if_block2;
    if (
      /*active*/
      ctx2[2] === "parent" /* parent */
    )
      return create_if_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function instance40($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { hasChildren } = $$props;
  let { active } = $$props;
  let { parentId } = $$props;
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("hasChildren" in $$props2)
      $$invalidate(1, hasChildren = $$props2.hasChildren);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("parentId" in $$props2)
      $$invalidate(3, parentId = $$props2.parentId);
  };
  return [editing, hasChildren, active, parentId];
}
var Bridges = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance40,
      create_fragment40,
      safe_not_equal,
      {
        editing: 0,
        hasChildren: 1,
        active: 2,
        parentId: 3
      },
      add_css12
    );
  }
};
var bridges_default = Bridges;

// src/view/components/container/column/components/group/components/card/components/dnd/droppable.svelte
var import_classnames2 = __toESM(require_classnames());
function add_css13(target) {
  append_styles(target, "svelte-cl9jzh", ".lineage-card.svelte-cl9jzh{width:var(--node-width);height:fit-content;display:flex;position:relative;font-size:16px}");
}
function create_fragment41(ctx) {
  let div;
  let t;
  let bridges;
  let div_class_value;
  let droppable_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  bridges = new bridges_default({
    props: {
      active: (
        /*active*/
        ctx[1]
      ),
      editing: (
        /*editing*/
        ctx[4]
      ),
      hasChildren: (
        /*hasChildren*/
        ctx[2]
      ),
      parentId: (
        /*parentId*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      create_component(bridges.$$.fragment);
      attr(div, "class", div_class_value = null_to_empty((0, import_classnames2.default)(
        "lineage-card",
        /*active*/
        ctx[1] ? (
          /*activeStatusClasses*/
          ctx[8][
            /*active*/
            ctx[1]
          ]
        ) : " inactive-node"
      )) + " svelte-cl9jzh");
      attr(
        div,
        "id",
        /*nodeId*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t);
      mount_component(bridges, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*setActive*/
            ctx[5]
          ),
          listen(
            div,
            "dblclick",
            /*dblclick_handler*/
            ctx[11]
          ),
          action_destroyer(droppable_action = droppable.call(null, div, {
            viewStore: (
              /*viewStore*/
              ctx[7]
            ),
            documentStore: (
              /*documentStore*/
              ctx[6]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      const bridges_changes = {};
      if (dirty & /*active*/
      2)
        bridges_changes.active = /*active*/
        ctx2[1];
      if (dirty & /*editing*/
      16)
        bridges_changes.editing = /*editing*/
        ctx2[4];
      if (dirty & /*hasChildren*/
      4)
        bridges_changes.hasChildren = /*hasChildren*/
        ctx2[2];
      if (dirty & /*parentId*/
      8)
        bridges_changes.parentId = /*parentId*/
        ctx2[3];
      bridges.$set(bridges_changes);
      if (!current || dirty & /*active*/
      2 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames2.default)(
        "lineage-card",
        /*active*/
        ctx2[1] ? (
          /*activeStatusClasses*/
          ctx2[8][
            /*active*/
            ctx2[1]
          ]
        ) : " inactive-node"
      )) + " svelte-cl9jzh")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*nodeId*/
      1) {
        attr(
          div,
          "id",
          /*nodeId*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(bridges.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(bridges.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(bridges);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance41($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { nodeId } = $$props;
  let { active } = $$props;
  let { hasChildren } = $$props;
  let { parentId } = $$props;
  let { editing } = $$props;
  const setActive = () => {
    if (!editing)
      viewStore.dispatch({
        type: "DOCUMENT/SET_ACTIVE_NODE",
        payload: { id: nodeId }
      });
  };
  const view = getView();
  const documentStore = view.documentStore;
  const viewStore = view.viewStore;
  const activeStatusClasses = {
    ["node" /* node */]: "active-node",
    ["child" /* child */]: "active-child",
    ["parent" /* parent */]: "active-parent",
    ["sibling" /* sibling */]: "active-sibling"
  };
  const dblclick_handler = () => {
    setActive();
    viewStore.dispatch({
      type: "DOCUMENT/ENABLE_EDIT_MODE",
      payload: { nodeId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
    if ("hasChildren" in $$props2)
      $$invalidate(2, hasChildren = $$props2.hasChildren);
    if ("parentId" in $$props2)
      $$invalidate(3, parentId = $$props2.parentId);
    if ("editing" in $$props2)
      $$invalidate(4, editing = $$props2.editing);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    nodeId,
    active,
    hasChildren,
    parentId,
    editing,
    setActive,
    documentStore,
    viewStore,
    activeStatusClasses,
    $$scope,
    slots,
    dblclick_handler
  ];
}
var Droppable = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance41,
      create_fragment41,
      safe_not_equal,
      {
        nodeId: 0,
        active: 1,
        hasChildren: 2,
        parentId: 3,
        editing: 4
      },
      add_css13
    );
  }
};
var droppable_default = Droppable;

// src/view/actions/inline-editor/load-inline-editor.ts
var loadInlineEditor = (target, { nodeId, view }) => {
  if (!view.file)
    return;
  view.inlineEditor.loadNode(target, nodeId);
  return {
    destroy: () => {
      if (view.inlineEditor.activeNode === nodeId) {
        view.documentStore.dispatch({
          type: "DOCUMENT/SET_NODE_CONTENT",
          payload: {
            nodeId,
            content: view.inlineEditor.getContent()
          }
        });
        view.inlineEditor.unloadNode();
      }
    }
  };
};

// src/view/actions/inline-editor/expandable-textarea-action.ts
var keys = /* @__PURE__ */ new Set(["Backspace", "Enter", "Delete", " ", "v"]);
var adjustHeight = (el, x) => {
  const height = x.style.height;
  x.style.height = "auto";
  el.style.height = x.scrollHeight + "px";
  x.style.height = height;
};
var expandableTextareaAction = (el) => {
  let x;
  const listener = (e) => {
    if (e && !keys.has(e.key))
      return;
    if (!x)
      x = el.querySelector(".cm-scroller");
    if (x) {
      adjustHeight(el, x);
    }
  };
  el.addEventListener("keydown", listener);
  return {
    destroy: () => {
      el.removeEventListener("keydown", listener);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/content/inline-editor.svelte
function add_css14(target) {
  append_styles(target, "svelte-1miwzcb", ".editor-container.svelte-1miwzcb{width:100%;min-height:100px;max-height:65vh;height:fit-content;overflow:hidden;display:flex}");
}
function create_fragment42(ctx) {
  let div;
  let expandableTextareaAction_action;
  let loadInlineEditor_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = ``;
      attr(div, "class", "editor-container svelte-1miwzcb");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(expandableTextareaAction_action = expandableTextareaAction.call(null, div)),
          action_destroyer(loadInlineEditor_action = loadInlineEditor.call(null, div, {
            nodeId: (
              /*nodeId*/
              ctx[0]
            ),
            view: (
              /*view*/
              ctx[1]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (loadInlineEditor_action && is_function(loadInlineEditor_action.update) && dirty & /*nodeId*/
      1)
        loadInlineEditor_action.update.call(null, {
          nodeId: (
            /*nodeId*/
            ctx2[0]
          ),
          view: (
            /*view*/
            ctx2[1]
          )
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance42($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  const view = getView();
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
  };
  return [nodeId, view];
}
var Inline_editor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance42, create_fragment42, safe_not_equal, { nodeId: 0 }, add_css14);
  }
};
var inline_editor_default = Inline_editor;

// src/view/actions/markdown-preview-action.ts
var import_obsidian3 = require("obsidian");
var markdownPreviewAction = (element2, content) => {
  const plugin = getPlugin();
  const view = getView();
  const store = view.documentStore;
  const render = (content2) => {
    if (view && element2) {
      element2.empty();
      import_obsidian3.MarkdownRenderer.render(
        plugin.app,
        content2,
        element2,
        store.getValue().file.path,
        view
      );
    }
  };
  render(content);
  return {
    update: (content2) => {
      render(content2);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/content/content.svelte
function add_css15(target) {
  append_styles(target, "svelte-1q2vzlv", ".preview-container.svelte-1q2vzlv{width:100%;min-height:100px;font-size:var(--font-text-size);padding:6px 6px 6px 12px;color-scheme:light\n    }");
}
function create_fragment43(ctx) {
  let div;
  let div_class_value;
  let markdownPreviewAction_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = null_to_empty("preview-container markdown-preview-view") + " svelte-1q2vzlv");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*onClick*/
            ctx[1]
          ),
          action_destroyer(markdownPreviewAction_action = markdownPreviewAction.call(
            null,
            div,
            /*content*/
            ctx[0]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (markdownPreviewAction_action && is_function(markdownPreviewAction_action.update) && dirty & /*content*/
      1)
        markdownPreviewAction_action.update.call(
          null,
          /*content*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance43($$self, $$props, $$invalidate) {
  let { active } = $$props;
  let { content } = $$props;
  const plugin = getPlugin();
  const view = getView();
  const store = view.documentStore;
  const onClick = (e) => {
    if (e.target instanceof HTMLAnchorElement) {
      if (e.target.hasClass("internal-link")) {
        const link = e.target.dataset.href;
        const path = store.getValue().file.path;
        if (link && path) {
          plugin.app.workspace.openLinkText(link, path, true);
        }
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
  };
  return [content, onClick, active];
}
var Content = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance43, create_fragment43, safe_not_equal, { active: 2, content: 0 }, add_css15);
  }
};
var content_default = Content;

// src/view/components/container/column/components/group/components/card/components/card-buttons/floating-button.svelte
var import_classnames3 = __toESM(require_classnames());
function add_css16(target) {
  append_styles(target, "svelte-19vetvm", ":root{--floating-button-width:30px;--floating-button-height:30px;--node-width:400px;--floating-button-bg:#dbdbdb;--position-tb:-10px;--position-lr:-4px}button.svelte-19vetvm{color:var(--color-acive-node);width:var(--floating-button-width);height:var(--floating-button-height);position:absolute;opacity:0;box-shadow:none;border:none;background-color:transparent;transition:opacity 200ms;padding:8px;cursor:pointer}.is-disabled.svelte-19vetvm{cursor:not-allowed}button.svelte-19vetvm:not(.is-disabled):hover{opacity:8}.position-top.svelte-19vetvm{top:var(--position-tb);left:calc(50% - calc(var(--floating-button-width) / 2))}.position-bottom.svelte-19vetvm{bottom:var(--position-tb);left:calc(50% - calc(var(--floating-button-width) / 2))}.position-right.svelte-19vetvm{top:calc(50% - calc(var(--floating-button-height) / 2));right:var(--position-lr)}.position-bottom-right.svelte-19vetvm{top:var(--position-lr);right:var(--position-lr)}.position-top-right.svelte-19vetvm{top:var(--position-lr);right:16px}");
}
function create_fragment44(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(
        button,
        "aria-label",
        /*label*/
        ctx[2]
      );
      attr(button, "class", button_class_value = null_to_empty((0, import_classnames3.default)(
        /*classes*/
        ctx[0],
        /*positionClasses*/
        ctx[3][
          /*position*/
          ctx[1]
        ],
        "lineage-floating-button"
      )) + " svelte-19vetvm");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*label*/
      4) {
        attr(
          button,
          "aria-label",
          /*label*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*classes, position*/
      3 && button_class_value !== (button_class_value = null_to_empty((0, import_classnames3.default)(
        /*classes*/
        ctx2[0],
        /*positionClasses*/
        ctx2[3][
          /*position*/
          ctx2[1]
        ],
        "lineage-floating-button"
      )) + " svelte-19vetvm")) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { classes = "" } = $$props;
  let { position } = $$props;
  let { label } = $$props;
  const positionClasses = {
    up: "position-top",
    right: "position-right",
    down: "position-bottom",
    "down-right": "position-bottom-right",
    "up-right": "position-top-right"
  };
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("classes" in $$props2)
      $$invalidate(0, classes = $$props2.classes);
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [classes, position, label, positionClasses, $$scope, slots, click_handler];
}
var Floating_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance44, create_fragment44, safe_not_equal, { classes: 0, position: 1, label: 2 }, add_css16);
  }
};
var floating_button_default = Floating_button;

// src/view/components/container/column/components/group/components/card/components/card-buttons/delete-node-button.svelte
function create_default_slot28(ctx) {
  let trashicon;
  let current;
  trashicon = new trash_default({ props: { class: "svg-con" } });
  return {
    c() {
      create_component(trashicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(trashicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(trashicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trashicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trashicon, detaching);
    }
  };
}
function create_fragment45(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: "Delete",
      position: "up-right",
      $$slots: { default: [create_default_slot28] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*deleteNode*/
    ctx[0]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*$$scope*/
      16) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance45($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  const view = getView();
  const documentStore = view.documentStore;
  const deleteNode2 = (e) => {
    e.stopPropagation();
    documentStore.dispatch({
      type: "DOCUMENT/DELETE_NODE",
      payload: { activeNodeId: nodeId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(1, nodeId = $$props2.nodeId);
  };
  return [deleteNode2, nodeId];
}
var Delete_node_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance45, create_fragment45, safe_not_equal, { nodeId: 1 });
  }
};
var delete_node_button_default = Delete_node_button;

// src/view/components/container/column/components/group/components/card/components/card-buttons/edit-node-button.svelte
function create_else_block2(ctx) {
  let pencilicon;
  let current;
  pencilicon = new pencil_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(pencilicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pencilicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(pencilicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pencilicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pencilicon, detaching);
    }
  };
}
function create_if_block3(ctx) {
  let saveicon;
  let current;
  saveicon = new save_default({ props: { class: "svg-con" } });
  return {
    c() {
      create_component(saveicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(saveicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(saveicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(saveicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(saveicon, detaching);
    }
  };
}
function create_default_slot29(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*editing*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment46(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: (
        /*editing*/
        ctx[0] ? "Save" : "Edit"
      ),
      position: "down-right",
      $$slots: { default: [create_default_slot29] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*toggleEdit*/
    ctx[1]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*editing*/
      1)
        floatingbutton_changes.label = /*editing*/
        ctx2[0] ? "Save" : "Edit";
      if (dirty & /*$$scope, editing*/
      33) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance46($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { nodeId } = $$props;
  const view = getView();
  const viewStore = view.viewStore;
  const toggleEdit = (e) => {
    e.stopPropagation();
    if (editing) {
      saveNodeContent(view);
    } else {
      viewStore.dispatch({
        type: "DOCUMENT/ENABLE_EDIT_MODE",
        payload: { nodeId }
      });
    }
  };
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("nodeId" in $$props2)
      $$invalidate(2, nodeId = $$props2.nodeId);
  };
  return [editing, toggleEdit, nodeId];
}
var Edit_node_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance46, create_fragment46, safe_not_equal, { editing: 0, nodeId: 2 });
  }
};
var edit_node_button_default = Edit_node_button;

// src/view/components/container/column/components/group/components/card/components/card-buttons/create-card-button.svelte
function create_default_slot30(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*chevrons*/
    ctx[2][
      /*position*/
      ctx[0]
    ]
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*position*/
      1 && switch_value !== (switch_value = /*chevrons*/
      ctx2[2][
        /*position*/
        ctx2[0]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment47(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: (
        /*label*/
        ctx[3][
          /*position*/
          ctx[0]
        ]
      ),
      position: (
        /*position*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot30] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*createCard*/
    ctx[1]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*position*/
      1)
        floatingbutton_changes.label = /*label*/
        ctx2[3][
          /*position*/
          ctx2[0]
        ];
      if (dirty & /*position*/
      1)
        floatingbutton_changes.position = /*position*/
        ctx2[0];
      if (dirty & /*$$scope, position*/
      33) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance47($$self, $$props, $$invalidate) {
  let { position } = $$props;
  const view = getView();
  const createCard = (e) => {
    e.stopPropagation();
    saveNodeAndInsertNode(view, position);
  };
  const chevrons = {
    right: chevron_right_default,
    up: chevron_up_default,
    down: chevron_down_default
  };
  const label = {
    "up": "Add card above",
    "down": "Add card below",
    "right": "Add child card"
  };
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
  };
  return [position, createCard, chevrons, label];
}
var Create_card_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance47, create_fragment47, safe_not_equal, { position: 0 });
  }
};
var create_card_button_default = Create_card_button;

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/stores/view/helpers/json-to-md/markdown-to-json/helpers/delimiter.ts
var level = (parentNumber, index) => `${parentNumber ? parentNumber + "." : ""}${index}`;
var delimiter = (parentNumber, index) => `
<!--section: ${level(parentNumber, index)}-->`;
var delimiterRegex = /\s*<!--\s*section:\s*((\d\.?)*(\d))[\w\s]*-->/;
var parseDelimiter = (line) => {
  const results = delimiterRegex.exec(line);
  if (results) {
    const result = results[1];
    const split = result.split(".");
    const index = split[split.length - 1];
    const parent = result.substring(0, result.length - index.length - 1);
    return [parent, index, result];
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/tree-index-button.svelte
function add_css17(target) {
  append_styles(target, "svelte-zzekbz", ".tree-index.svelte-zzekbz{position:absolute;bottom:3px;right:8px;opacity:0.8;font-size:12px;cursor:pointer}.is-active.svelte-zzekbz{opacity:0.3}.is-active-child.svelte-zzekbz{opacity:0.3}.is-active-parent.svelte-zzekbz{opacity:0.6}");
}
function create_fragment48(ctx) {
  let div;
  let t_value = (
    /*$viewStore*/
    ctx[2].document.treeIndex[
      /*nodeId*/
      ctx[0]
    ] + ""
  );
  let t;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "aria-label", "Jump to section");
      attr(div, "class", div_class_value = null_to_empty("tree-index " + /*activeStatus*/
      (ctx[1] ? (
        /*classes*/
        ctx[5][
          /*activeStatus*/
          ctx[1]
        ]
      ) : "")) + " svelte-zzekbz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*openFile*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$viewStore, nodeId*/
      5 && t_value !== (t_value = /*$viewStore*/
      ctx2[2].document.treeIndex[
        /*nodeId*/
        ctx2[0]
      ] + ""))
        set_data(t, t_value);
      if (dirty & /*activeStatus*/
      2 && div_class_value !== (div_class_value = null_to_empty("tree-index " + /*activeStatus*/
      (ctx2[1] ? (
        /*classes*/
        ctx2[5][
          /*activeStatus*/
          ctx2[1]
        ]
      ) : "")) + " svelte-zzekbz")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance48($$self, $$props, $$invalidate) {
  let $viewStore;
  const plugin = getPlugin();
  const view = getView();
  const viewStore = view.viewStore;
  component_subscribe($$self, viewStore, (value) => $$invalidate(2, $viewStore = value));
  let { nodeId } = $$props;
  let { activeStatus } = $$props;
  const openFileAndJumpToLine = (file, line, ch) => __awaiter(void 0, void 0, void 0, function* () {
    const leaf = plugin.app.workspace.getLeaf("split");
    plugin.settings.dispatch({
      type: "SET_DOCUMENT_TYPE_TO_MARKDOWN",
      payload: { path: file.path }
    });
    yield leaf.openFile(file);
    const markdownView = leaf.view;
    markdownView.editor.setCursor({ line, ch });
    plugin.settings.dispatch({
      type: "SET_DOCUMENT_TYPE_TO_TREE",
      payload: { path: file.path }
    });
  });
  const openFile2 = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!view.file)
      return;
    const treeIndex = get_store_value(viewStore).document.treeIndex[nodeId];
    const lines = view.data.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.startsWith("<!--")) {
        const section = parseDelimiter(line);
        if (section && section[2] === treeIndex) {
          const nextLineIndex = i + 1;
          const nextLine = lines[nextLineIndex] || "";
          yield openFileAndJumpToLine(view.file, nextLineIndex, nextLine.length);
        }
      }
    }
  });
  const classes = {
    ["node" /* node */]: "is-active",
    ["child" /* child */]: "is-active-child",
    ["parent" /* parent */]: "is-active-parent",
    ["sibling" /* sibling */]: "is-active-parent"
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
    if ("activeStatus" in $$props2)
      $$invalidate(1, activeStatus = $$props2.activeStatus);
  };
  return [nodeId, activeStatus, $viewStore, viewStore, openFile2, classes];
}
var Tree_index_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance48, create_fragment48, safe_not_equal, { nodeId: 0, activeStatus: 1 }, add_css17);
  }
};
var tree_index_button_default = Tree_index_button;

// src/view/components/container/column/components/group/components/card/components/card-buttons/card-buttons.svelte
function create_if_block4(ctx) {
  let t;
  let editnodebutton;
  let current;
  let if_block = !/*editing*/
  ctx[0] && create_if_block_12(ctx);
  editnodebutton = new edit_node_button_default({
    props: {
      editing: (
        /*editing*/
        ctx[0]
      ),
      nodeId: (
        /*nodeId*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(editnodebutton.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(editnodebutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*editing*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editing*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const editnodebutton_changes = {};
      if (dirty & /*editing*/
      1)
        editnodebutton_changes.editing = /*editing*/
        ctx2[0];
      if (dirty & /*nodeId*/
      4)
        editnodebutton_changes.nodeId = /*nodeId*/
        ctx2[2];
      editnodebutton.$set(editnodebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(editnodebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(editnodebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(editnodebutton, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let createcardbutton0;
  let t0;
  let createcardbutton1;
  let t1;
  let createcardbutton2;
  let t2;
  let deletenodebutton;
  let current;
  createcardbutton0 = new create_card_button_default({ props: { position: "up" } });
  createcardbutton1 = new create_card_button_default({ props: { position: "right" } });
  createcardbutton2 = new create_card_button_default({ props: { position: "down" } });
  deletenodebutton = new delete_node_button_default({ props: { nodeId: (
    /*nodeId*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(createcardbutton0.$$.fragment);
      t0 = space();
      create_component(createcardbutton1.$$.fragment);
      t1 = space();
      create_component(createcardbutton2.$$.fragment);
      t2 = space();
      create_component(deletenodebutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(createcardbutton0, target, anchor);
      insert(target, t0, anchor);
      mount_component(createcardbutton1, target, anchor);
      insert(target, t1, anchor);
      mount_component(createcardbutton2, target, anchor);
      insert(target, t2, anchor);
      mount_component(deletenodebutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const deletenodebutton_changes = {};
      if (dirty & /*nodeId*/
      4)
        deletenodebutton_changes.nodeId = /*nodeId*/
        ctx2[2];
      deletenodebutton.$set(deletenodebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(createcardbutton0.$$.fragment, local);
      transition_in(createcardbutton1.$$.fragment, local);
      transition_in(createcardbutton2.$$.fragment, local);
      transition_in(deletenodebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(createcardbutton0.$$.fragment, local);
      transition_out(createcardbutton1.$$.fragment, local);
      transition_out(createcardbutton2.$$.fragment, local);
      transition_out(deletenodebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(createcardbutton0, detaching);
      destroy_component(createcardbutton1, detaching);
      destroy_component(createcardbutton2, detaching);
      destroy_component(deletenodebutton, detaching);
    }
  };
}
function create_fragment49(ctx) {
  let t;
  let treeindex;
  let current;
  let if_block = (
    /*active*/
    ctx[1] === "node" /* node */ && create_if_block4(ctx)
  );
  treeindex = new tree_index_button_default({
    props: {
      activeStatus: (
        /*active*/
        ctx[1]
      ),
      nodeId: (
        /*nodeId*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(treeindex.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(treeindex, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*active*/
        ctx2[1] === "node" /* node */
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*active*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const treeindex_changes = {};
      if (dirty & /*active*/
      2)
        treeindex_changes.activeStatus = /*active*/
        ctx2[1];
      if (dirty & /*nodeId*/
      4)
        treeindex_changes.nodeId = /*nodeId*/
        ctx2[2];
      treeindex.$set(treeindex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(treeindex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(treeindex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(treeindex, detaching);
    }
  };
}
function instance49($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { active } = $$props;
  let { nodeId } = $$props;
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
    if ("nodeId" in $$props2)
      $$invalidate(2, nodeId = $$props2.nodeId);
  };
  return [editing, active, nodeId];
}
var Card_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance49, create_fragment49, safe_not_equal, { editing: 0, active: 1, nodeId: 2 });
  }
};
var card_buttons_default = Card_buttons;

// src/view/components/container/column/components/group/components/card/card.svelte
function create_else_block3(ctx) {
  let draggable2;
  let current;
  draggable2 = new draggable_default({
    props: {
      nodeId: (
        /*node*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(draggable2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draggable2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const draggable_changes = {};
      if (dirty & /*node*/
      1)
        draggable_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*$$scope, active, $store, node*/
      293) {
        draggable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      draggable2.$set(draggable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(draggable2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draggable2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(draggable2, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let inlineeditor;
  let current;
  inlineeditor = new inline_editor_default({ props: { nodeId: (
    /*node*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(inlineeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlineeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlineeditor_changes = {};
      if (dirty & /*node*/
      1)
        inlineeditor_changes.nodeId = /*node*/
        ctx2[0];
      inlineeditor.$set(inlineeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlineeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlineeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlineeditor, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let content;
  let current;
  content = new content_default({
    props: {
      active: (
        /*active*/
        ctx[2]
      ),
      content: (
        /*$store*/
        ctx[5].document.content[
          /*node*/
          ctx[0]
        ]?.content || ""
      )
    }
  });
  return {
    c() {
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const content_changes = {};
      if (dirty & /*active*/
      4)
        content_changes.active = /*active*/
        ctx2[2];
      if (dirty & /*$store, node*/
      33)
        content_changes.content = /*$store*/
        ctx2[5].document.content[
          /*node*/
          ctx2[0]
        ]?.content || "";
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(content, detaching);
    }
  };
}
function create_default_slot31(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let cardbuttons;
  let current;
  const if_block_creators = [create_if_block5, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*active*/
      ctx2[2] === "node" /* node */ && /*editing*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  cardbuttons = new card_buttons_default({
    props: {
      active: (
        /*active*/
        ctx[2]
      ),
      editing: (
        /*editing*/
        ctx[1]
      ),
      nodeId: (
        /*node*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      if_block.c();
      t = space();
      create_component(cardbuttons.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      mount_component(cardbuttons, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      const cardbuttons_changes = {};
      if (dirty & /*active*/
      4)
        cardbuttons_changes.active = /*active*/
        ctx2[2];
      if (dirty & /*editing*/
      2)
        cardbuttons_changes.editing = /*editing*/
        ctx2[1];
      if (dirty & /*node*/
      1)
        cardbuttons_changes.nodeId = /*node*/
        ctx2[0];
      cardbuttons.$set(cardbuttons_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(cardbuttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(cardbuttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(cardbuttons, detaching);
    }
  };
}
function create_fragment50(ctx) {
  let droppable2;
  let current;
  droppable2 = new droppable_default({
    props: {
      active: (
        /*active*/
        ctx[2]
      ),
      editing: (
        /*editing*/
        ctx[1]
      ),
      hasChildren: (
        /*hasChildren*/
        ctx[3]
      ),
      nodeId: (
        /*node*/
        ctx[0]
      ),
      parentId: (
        /*parentId*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot31] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(droppable2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(droppable2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const droppable_changes = {};
      if (dirty & /*active*/
      4)
        droppable_changes.active = /*active*/
        ctx2[2];
      if (dirty & /*editing*/
      2)
        droppable_changes.editing = /*editing*/
        ctx2[1];
      if (dirty & /*hasChildren*/
      8)
        droppable_changes.hasChildren = /*hasChildren*/
        ctx2[3];
      if (dirty & /*node*/
      1)
        droppable_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*parentId*/
      16)
        droppable_changes.parentId = /*parentId*/
        ctx2[4];
      if (dirty & /*$$scope, active, editing, node, $store*/
      295) {
        droppable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      droppable2.$set(droppable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(droppable2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(droppable2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(droppable2, detaching);
    }
  };
}
function instance50($$self, $$props, $$invalidate) {
  let $store;
  let { node } = $$props;
  let { editing } = $$props;
  let { active } = $$props;
  let { hasChildren } = $$props;
  let { parentId } = $$props;
  const view = getView();
  const store = view.documentStore;
  component_subscribe($$self, store, (value) => $$invalidate(5, $store = value));
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("editing" in $$props2)
      $$invalidate(1, editing = $$props2.editing);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("hasChildren" in $$props2)
      $$invalidate(3, hasChildren = $$props2.hasChildren);
    if ("parentId" in $$props2)
      $$invalidate(4, parentId = $$props2.parentId);
  };
  return [node, editing, active, hasChildren, parentId, $store, store];
}
var Card = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      node: 0,
      editing: 1,
      active: 2,
      hasChildren: 3,
      parentId: 4
    });
  }
};
var card_default = Card;

// src/view/components/container/column/components/group/group.svelte
var import_classnames4 = __toESM(require_classnames());
function add_css18(target) {
  append_styles(target, "svelte-xlnpke", ".group.svelte-xlnpke{display:flex;flex-direction:column;width:fit-content;gap:4px;padding:8px}.group.svelte-xlnpke:last-child{margin-bottom:0}.group-has-active-parent.svelte-xlnpke{border-bottom-left-radius:6px;border-top-left-radius:6px}");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_if_block6(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let div_id_value;
  let current;
  let each_value = ensure_array_like(
    /*group*/
    ctx[0].nodes
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[6]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context7(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block7(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", div_class_value = null_to_empty((0, import_classnames4.default)(
        "group",
        /*$viewStore*/
        ctx[1].document.activeBranch.childGroups.has(
          /*group*/
          ctx[0].parentId
        ) && "group-has-active-parent",
        /*$viewStore*/
        ctx[1].document.activeBranch.group === /*group*/
        ctx[0].parentId && "group-has-active-node"
      )) + " svelte-xlnpke");
      attr(div, "id", div_id_value = "group-" + /*group*/
      ctx[0].parentId);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*group, $viewStore, parentNodes*/
      7) {
        each_value = ensure_array_like(
          /*group*/
          ctx2[0].nodes
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block7, null, get_each_context7);
        check_outros();
      }
      if (!current || dirty & /*$viewStore, group*/
      3 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames4.default)(
        "group",
        /*$viewStore*/
        ctx2[1].document.activeBranch.childGroups.has(
          /*group*/
          ctx2[0].parentId
        ) && "group-has-active-parent",
        /*$viewStore*/
        ctx2[1].document.activeBranch.group === /*group*/
        ctx2[0].parentId && "group-has-active-node"
      )) + " svelte-xlnpke")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*group*/
      1 && div_id_value !== (div_id_value = "group-" + /*group*/
      ctx2[0].parentId)) {
        attr(div, "id", div_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_if_block_13(ctx) {
  let node_1;
  let current;
  node_1 = new card_default({
    props: {
      node: (
        /*node*/
        ctx[6]
      ),
      active: (
        /*node*/
        ctx[6] === /*$viewStore*/
        ctx[1].document.activeNode ? "node" /* node */ : (
          /*parentNodes*/
          ctx[2].has(
            /*node*/
            ctx[6]
          ) ? "parent" /* parent */ : (
            /*$viewStore*/
            ctx[1].document.activeBranch.childGroups.has(
              /*group*/
              ctx[0].parentId
            ) ? "child" /* child */ : (
              /*$viewStore*/
              ctx[1].document.activeBranch.group === /*group*/
              ctx[0].parentId ? "sibling" /* sibling */ : null
            )
          )
        )
      ),
      editing: (
        /*$viewStore*/
        ctx[1].document.editing.activeNodeId === /*node*/
        ctx[6]
      ),
      hasChildren: (
        /*$viewStore*/
        ctx[1].document.activeBranch.childGroups.size > 0
      ),
      parentId: (
        /*group*/
        ctx[0].parentId
      )
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const node_1_changes = {};
      if (dirty & /*group*/
      1)
        node_1_changes.node = /*node*/
        ctx2[6];
      if (dirty & /*group, $viewStore, parentNodes*/
      7)
        node_1_changes.active = /*node*/
        ctx2[6] === /*$viewStore*/
        ctx2[1].document.activeNode ? "node" /* node */ : (
          /*parentNodes*/
          ctx2[2].has(
            /*node*/
            ctx2[6]
          ) ? "parent" /* parent */ : (
            /*$viewStore*/
            ctx2[1].document.activeBranch.childGroups.has(
              /*group*/
              ctx2[0].parentId
            ) ? "child" /* child */ : (
              /*$viewStore*/
              ctx2[1].document.activeBranch.group === /*group*/
              ctx2[0].parentId ? "sibling" /* sibling */ : null
            )
          )
        );
      if (dirty & /*$viewStore, group*/
      3)
        node_1_changes.editing = /*$viewStore*/
        ctx2[1].document.editing.activeNodeId === /*node*/
        ctx2[6];
      if (dirty & /*$viewStore*/
      2)
        node_1_changes.hasChildren = /*$viewStore*/
        ctx2[1].document.activeBranch.childGroups.size > 0;
      if (dirty & /*group*/
      1)
        node_1_changes.parentId = /*group*/
        ctx2[0].parentId;
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function create_each_block7(key_1, ctx) {
  let first;
  let show_if = (
    /*$viewStore*/
    ctx[1].search.query.length === 0 || !/*$viewStore*/
    ctx[1].search.searching && /*$viewStore*/
    ctx[1].search.results.has(
      /*node*/
      ctx[6]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_13(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$viewStore, group*/
      3)
        show_if = /*$viewStore*/
        ctx[1].search.query.length === 0 || !/*$viewStore*/
        ctx[1].search.searching && /*$viewStore*/
        ctx[1].search.results.has(
          /*node*/
          ctx[6]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$viewStore, group*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment51(ctx) {
  let show_if = (
    /*group*/
    ctx[0].nodes.length > 0 && /*$viewStore*/
    (ctx[1].search.query.length === 0 || /*group*/
    ctx[0].nodes.some(
      /*func*/
      ctx[4]
    ))
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block6(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*group, $viewStore*/
      3)
        show_if = /*group*/
        ctx2[0].nodes.length > 0 && /*$viewStore*/
        (ctx2[1].search.query.length === 0 || /*group*/
        ctx2[0].nodes.some(
          /*func*/
          ctx2[4]
        ));
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*group, $viewStore*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance51($$self, $$props, $$invalidate) {
  let $viewStore;
  const view = getView();
  const viewStore = view.viewStore;
  component_subscribe($$self, viewStore, (value) => $$invalidate(1, $viewStore = value));
  let { group } = $$props;
  let parentNodes = /* @__PURE__ */ new Set();
  const func2 = (n) => $viewStore.search.results.has(n);
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group = $$props2.group);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$viewStore*/
    2) {
      $:
        $$invalidate(2, parentNodes = new Set($viewStore.document.activeBranch.sortedParentNodes));
    }
  };
  return [group, $viewStore, parentNodes, viewStore, func2];
}
var Group2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance51, create_fragment51, safe_not_equal, { group: 0 }, add_css18);
  }
};
var group_default2 = Group2;

// src/view/components/container/column/column.svelte
function add_css19(target) {
  append_styles(target, "svelte-1wrq2h3", ".column.svelte-1wrq2h3{width:fit-content;min-width:416px;height:100vh;overflow-y:scroll;overflow-x:hidden}.column.svelte-1wrq2h3::-webkit-scrollbar{display:none}.column-buffer.svelte-1wrq2h3{height:60%\n    }");
}
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_if_block7(ctx) {
  let group_1;
  let current;
  group_1 = new group_default2({ props: { group: (
    /*group*/
    ctx[4]
  ) } });
  return {
    c() {
      create_component(group_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(group_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const group_1_changes = {};
      if (dirty & /*column*/
      1)
        group_1_changes.group = /*group*/
        ctx2[4];
      group_1.$set(group_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(group_1, detaching);
    }
  };
}
function create_each_block8(key_1, ctx) {
  let first;
  let show_if = !/*$viewStore*/
  ctx[1].document.dnd.childGroups.has(
    /*group*/
    ctx[4].parentId
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block7(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$viewStore, column*/
      3)
        show_if = !/*$viewStore*/
        ctx[1].document.dnd.childGroups.has(
          /*group*/
          ctx[4].parentId
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$viewStore, column*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment52(ctx) {
  let div2;
  let div0;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div1;
  let div2_id_value;
  let current;
  let each_value = ensure_array_like(
    /*column*/
    ctx[0].groups
  );
  const get_key = (ctx2) => (
    /*group*/
    ctx2[4].parentId
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context8(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block8(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div1 = element("div");
      attr(div0, "class", "column-buffer svelte-1wrq2h3");
      attr(div1, "class", "column-buffer svelte-1wrq2h3");
      attr(div2, "class", "column svelte-1wrq2h3");
      attr(div2, "id", div2_id_value = /*column*/
      ctx[0].id);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div2, t1);
      append(div2, div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*column, $viewStore*/
      3) {
        each_value = ensure_array_like(
          /*column*/
          ctx2[0].groups
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div2, outro_and_destroy_block, create_each_block8, t1, get_each_context8);
        check_outros();
      }
      if (!current || dirty & /*column*/
      1 && div2_id_value !== (div2_id_value = /*column*/
      ctx2[0].id)) {
        attr(div2, "id", div2_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance52($$self, $$props, $$invalidate) {
  let $viewStore;
  const view = getView();
  const viewStore = view.viewStore;
  component_subscribe($$self, viewStore, (value) => $$invalidate(1, $viewStore = value));
  let { column } = $$props;
  $$self.$$set = ($$props2) => {
    if ("column" in $$props2)
      $$invalidate(0, column = $$props2.column);
  };
  return [column, $viewStore, viewStore];
}
var Column = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance52, create_fragment52, safe_not_equal, { column: 0 }, add_css19);
  }
};
var column_default = Column;

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/event-to-string.ts
var eventToString = (event) => {
  let string = event.key.toUpperCase();
  if (event.altKey)
    string += "Alt" /* Alt */;
  if (event.ctrlKey)
    string += "Ctrl" /* Ctrl */;
  if (event.shiftKey)
    string += "Shift" /* Shift */;
  return string;
};

// src/view/actions/keyboard-shortcuts/keyboard-shortcuts.ts
var import_obsidian4 = require("obsidian");
var keyboardShortcuts = (target, {
  view
}) => {
  const event = "keydown";
  const unsubscribeFromHotkeyStore = hotkeyStore.subscribe(
    (state, action, initialRun) => {
      if (action?.type === "HOTKEY/UPDATE" || action?.type === "HOTKEY/RESET" || initialRun)
        updateCommandsDictionary(state.hotkeys);
    }
  );
  const keyboardEventHandler = (event2) => {
    if (!(event2 instanceof KeyboardEvent))
      return;
    const command = commandsDictionary.current[eventToString(event2)];
    if (command) {
      if (command.check(view)) {
        try {
          command.callback(view, event2);
        } catch (error) {
          console.error(`[hotkey] command: `, command.name);
          console.error(`[hotkey] `, error);
          new import_obsidian4.Notice("Lineage plugin: " + error.message);
        }
      }
    }
  };
  target.addEventListener(event, keyboardEventHandler);
  return {
    destroy: () => {
      unsubscribeFromHotkeyStore();
      target.removeEventListener(event, keyboardEventHandler);
    }
  };
};

// src/view/components/container/container.svelte
function add_css20(target) {
  append_styles(target, "svelte-g9hp77", ".columns-container.svelte-g9hp77{position:relative;flex:1;height:100%;width:100%;display:flex;align-items:center;justify-content:start;padding-left:100px;margin-right:50px;overflow-y:hidden;overflow-x:auto}.columns.svelte-g9hp77{display:flex;align-items:center;width:100%}");
}
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block9(key_1, ctx) {
  let first;
  let column_1;
  let current;
  column_1 = new column_default({ props: { column: (
    /*column*/
    ctx[3]
  ) } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(column_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(column_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const column_1_changes = {};
      if (dirty & /*$store*/
      1)
        column_1_changes.column = /*column*/
        ctx[3];
      column_1.$set(column_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(column_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(column_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(column_1, detaching);
    }
  };
}
function create_fragment53(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let keyboardShortcuts_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$store*/
    ctx[0].document.columns
  );
  const get_key = (ctx2) => (
    /*column*/
    ctx2[3].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context9(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block9(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "columns svelte-g9hp77");
      attr(div1, "class", "columns-container svelte-g9hp77");
      attr(div1, "id", "columns-container");
      attr(div1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(keyboardShortcuts_action = keyboardShortcuts.call(null, div1, { view: (
          /*view*/
          ctx[1]
        ) }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$store*/
      1) {
        each_value = ensure_array_like(
          /*$store*/
          ctx2[0].document.columns
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block9, null, get_each_context9);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance53($$self, $$props, $$invalidate) {
  let $store;
  const view = getView();
  const store = view.documentStore;
  component_subscribe($$self, store, (value) => $$invalidate(0, $store = value));
  return [$store, view, store];
}
var Container = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance53, create_fragment53, safe_not_equal, {}, add_css20);
  }
};
var container_default = Container;

// src/view/components/container/breadcrumbs/breadcrumbs.svelte
function add_css21(target) {
  append_styles(target, "svelte-73tnlx", "button.svelte-73tnlx:disabled{cursor:not-allowed}.breadcrumbs-container.svelte-73tnlx{z-index:var(--z-index-breadcrumbs);left:var(--size-4-2);bottom:var(--size-4-2);display:flex;position:absolute}.breadcrumbs.svelte-73tnlx{display:flex;align-items:center;justify-content:center;border-radius:var(--radius-s);background-color:var(--interactive-normal);border:1px solid var(--background-modifier-border);box-shadow:var(--input-shadow);overflow:hidden}.breadcrumbs-item.svelte-73tnlx{box-shadow:none;height:30px;display:flex;line-height:1;font-size:inherit;align-items:center;justify-content:center;padding:var(--size-4-2);border-bottom:1px solid var(--background-modifier-border);color:var(--text-muted);background-color:var(--interactive-normal);--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width);cursor:pointer}.breadcrumbs-item.svelte-73tnlx:hover{background-color:var(--interactive-hover)}.breadcrumbs-item.svelte-73tnlx:last-child{border-bottom:none}.breadcrumbs-item-text.svelte-73tnlx{max-width:200px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}");
}
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_if_block8(ctx) {
  let chevronright;
  let current;
  chevronright = new chevron_right_default({
    props: { class: "svg-icon chevron", size: "12" }
  });
  return {
    c() {
      create_component(chevronright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevronright, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevronright, detaching);
    }
  };
}
function create_each_block10(ctx) {
  let t0;
  let button;
  let span;
  let t1_value = (
    /*$documentStore*/
    (ctx[1].document.content[
      /*parent*/
      ctx[6]
    ]?.content || "(empty)") + ""
  );
  let t1;
  let t2;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*i*/
    ctx[8] > 0 && create_if_block8(ctx)
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[4](
        /*parent*/
        ctx[6]
      )
    );
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      button = element("button");
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span, "class", "breadcrumbs-item-text svelte-73tnlx");
      attr(button, "aria-label", button_aria_label_value = /*$documentStore*/
      ctx[1].document.content[
        /*parent*/
        ctx[6]
      ]?.content || "Empty parent");
      attr(button, "class", "breadcrumbs-item svelte-73tnlx");
      attr(button, "data-tooltip-position", "up");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, button, anchor);
      append(button, span);
      append(span, t1);
      append(button, t2);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*$documentStore, $viewStore*/
      3) && t1_value !== (t1_value = /*$documentStore*/
      (ctx[1].document.content[
        /*parent*/
        ctx[6]
      ]?.content || "(empty)") + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*$documentStore, $viewStore*/
      3 && button_aria_label_value !== (button_aria_label_value = /*$documentStore*/
      ctx[1].document.content[
        /*parent*/
        ctx[6]
      ]?.content || "Empty parent")) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(button);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment54(ctx) {
  let div1;
  let div0;
  let current;
  let each_value = ensure_array_like(
    /*$viewStore*/
    ctx[0].document.activeBranch.sortedParentNodes
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "breadcrumbs svelte-73tnlx");
      attr(div1, "class", "breadcrumbs-container svelte-73tnlx");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$documentStore, $viewStore, viewStore*/
      7) {
        each_value = ensure_array_like(
          /*$viewStore*/
          ctx2[0].document.activeBranch.sortedParentNodes
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block10(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance54($$self, $$props, $$invalidate) {
  let $viewStore;
  let $documentStore;
  const view = getView();
  const viewStore = view.viewStore;
  component_subscribe($$self, viewStore, (value) => $$invalidate(0, $viewStore = value));
  const documentStore = view.documentStore;
  component_subscribe($$self, documentStore, (value) => $$invalidate(1, $documentStore = value));
  const click_handler = (parent) => {
    viewStore.dispatch({
      type: "DOCUMENT/SET_ACTIVE_NODE",
      payload: { id: parent }
    });
  };
  return [$viewStore, $documentStore, viewStore, documentStore, click_handler];
}
var Breadcrumbs = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance54, create_fragment54, safe_not_equal, {}, add_css21);
  }
};
var breadcrumbs_default = Breadcrumbs;

// src/view/components/container/navigation-history/navigation-history.svelte
function add_css22(target) {
  append_styles(target, "svelte-a2mded", ".navigation-history-container.svelte-a2mded{z-index:var(--z-index-breadcrumbs);left:var(--size-4-2);top:var(--size-4-2);display:flex;position:absolute}.navigation-history.svelte-a2mded{display:flex;align-items:center;justify-content:center;border-radius:var(--radius-s);background-color:var(--interactive-normal);border:1px solid var(--background-modifier-border);box-shadow:var(--input-shadow);overflow:hidden}.navigation-button.svelte-a2mded{box-shadow:none;display:flex;line-height:1;font-size:inherit;align-items:center;justify-content:center;padding:var(--size-4-2);width:30px;height:30px;border-bottom:1px solid var(--background-modifier-border);color:var(--text-muted);background-color:var(--interactive-normal);--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width);cursor:pointer}.navigation-button.svelte-a2mded:hover{background-color:var(--interactive-hover)}.navigation-button.svelte-a2mded:last-child{border-bottom:none}button.svelte-a2mded:disabled{cursor:not-allowed;color:var(--color-base-40)}");
}
function create_fragment55(ctx) {
  let div1;
  let div0;
  let button0;
  let arrowleft;
  let button0_aria_label_value;
  let button0_disabled_value;
  let t;
  let button1;
  let arrowright;
  let button1_aria_label_value;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  arrowleft = new arrow_left_default({ props: { class: "svg-icon", size: "12" } });
  arrowright = new arrow_right_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      create_component(arrowleft.$$.fragment);
      t = space();
      button1 = element("button");
      create_component(arrowright.$$.fragment);
      attr(button0, "aria-label", button0_aria_label_value = "Navigate back");
      attr(button0, "class", "navigation-button svelte-a2mded");
      attr(button0, "data-tooltip-position", "bottom");
      button0.disabled = button0_disabled_value = !/*$viewStore*/
      ctx[0].navigationHistory.state.canGoBack;
      attr(button1, "aria-label", button1_aria_label_value = "Navigate forward");
      attr(button1, "class", "navigation-button svelte-a2mded");
      attr(button1, "data-tooltip-position", "bottom");
      button1.disabled = button1_disabled_value = !/*$viewStore*/
      ctx[0].navigationHistory.state.canGoForward;
      attr(div0, "class", "navigation-history svelte-a2mded");
      attr(div1, "class", "navigation-history-container svelte-a2mded");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      mount_component(arrowleft, button0, null);
      append(div0, t);
      append(div0, button1);
      mount_component(arrowright, button1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$viewStore*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*$viewStore*/
      ctx2[0].navigationHistory.state.canGoBack)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty & /*$viewStore*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*$viewStore*/
      ctx2[0].navigationHistory.state.canGoForward)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowleft.$$.fragment, local);
      transition_in(arrowright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowleft.$$.fragment, local);
      transition_out(arrowright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(arrowleft);
      destroy_component(arrowright);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance55($$self, $$props, $$invalidate) {
  let $viewStore;
  const view = getView();
  const viewStore = view.viewStore;
  component_subscribe($$self, viewStore, (value) => $$invalidate(0, $viewStore = value));
  const click_handler = () => {
    viewStore.dispatch({ type: "NAVIGATION/NAVIGATE_BACK" });
  };
  const click_handler_1 = () => {
    viewStore.dispatch({ type: "NAVIGATION/NAVIGATE_FORWARD" });
  };
  return [$viewStore, viewStore, click_handler, click_handler_1];
}
var Navigation_history = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance55, create_fragment55, safe_not_equal, {}, add_css22);
  }
};
var navigation_history_default = Navigation_history;

// src/view/components/container/search-bar/search-bar.svelte
function add_css23(target) {
  append_styles(target, "svelte-m4r2cx", ".search-container.svelte-m4r2cx{z-index:var(--z-index-breadcrumbs);top:var(--size-4-2);left:calc(70px + var(--size-4-2));position:absolute;display:flex;align-items:center;justify-content:center;border-radius:var(--radius-s);background-color:var(--interactive-normal);border:1px solid var(--background-modifier-border);box-shadow:var(--input-shadow);overflow:hidden}.search-input-element.svelte-m4r2cx{height:30px;width:300px}.search-toggle.svelte-m4r2cx{cursor:pointer}.search-toggle-active.svelte-m4r2cx{background-color:var(--color-base-40)}");
}
function create_if_block9(ctx) {
  let div1;
  let input;
  let input_value_value;
  let input_placeholder_value;
  let input_autofocus_value;
  let t;
  let div0;
  let div0_style_value;
  let div0_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      input.value = input_value_value = /*$viewStore*/
      ctx[0].search.query;
      attr(input, "class", "search-input search-input-element svelte-m4r2cx");
      attr(input, "enterkeyhint", "search");
      attr(input, "placeholder", input_placeholder_value = "search");
      attr(input, "spellcheck", "false");
      attr(input, "type", "search");
      input.autofocus = input_autofocus_value = true;
      attr(input, "aria-label", "Search document");
      attr(div0, "style", div0_style_value = /*$viewStore*/
      ctx[0].search.query ? "" : "display: none");
      attr(div0, "aria-label", div0_aria_label_value = "Clear");
      attr(div0, "class", "search-input-clear-button");
      attr(div1, "class", "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      append(div1, t);
      append(div1, div0);
      if (true)
        input.focus();
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*onInput*/
            ctx[2]
          ),
          listen(
            div0,
            "click",
            /*click_handler_1*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$viewStore*/
      1 && input_value_value !== (input_value_value = /*$viewStore*/
      ctx2[0].search.query) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (dirty & /*$viewStore*/
      1 && div0_style_value !== (div0_style_value = /*$viewStore*/
      ctx2[0].search.query ? "" : "display: none")) {
        attr(div0, "style", div0_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment56(ctx) {
  let div;
  let button;
  let search2;
  let button_aria_label_value;
  let button_class_value;
  let t;
  let current;
  let mounted;
  let dispose;
  search2 = new search_default({ props: { class: "svg-icon", size: "12" } });
  let if_block = (
    /*$viewStore*/
    ctx[0].search.showInput && create_if_block9(ctx)
  );
  return {
    c() {
      div = element("div");
      button = element("button");
      create_component(search2.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(button, "aria-label", button_aria_label_value = "Toggle search input");
      attr(button, "class", button_class_value = null_to_empty("search-toggle " + /*$viewStore*/
      (ctx[0].search.showInput ? "search-toggle-active" : "")) + " svelte-m4r2cx");
      attr(button, "data-tooltip-position", "bottom");
      attr(div, "class", "search-container svelte-m4r2cx");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      mount_component(search2, button, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$viewStore*/
      1 && button_class_value !== (button_class_value = null_to_empty("search-toggle " + /*$viewStore*/
      (ctx2[0].search.showInput ? "search-toggle-active" : "")) + " svelte-m4r2cx")) {
        attr(button, "class", button_class_value);
      }
      if (
        /*$viewStore*/
        ctx2[0].search.showInput
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(search2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(search2);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance56($$self, $$props, $$invalidate) {
  let $viewStore;
  const view = getView();
  const viewStore = view.viewStore;
  component_subscribe($$self, viewStore, (value) => $$invalidate(0, $viewStore = value));
  const onInput = (
    // eslint-disable-next-line no-undef
    (e) => {
      viewStore.dispatch({
        type: "SEARCH/SET_QUERY",
        payload: { query: e.currentTarget.value }
      });
    }
  );
  const click_handler = () => {
    viewStore.dispatch({ type: "SEARCH/TOGGLE_INPUT" });
  };
  const click_handler_1 = () => {
    viewStore.dispatch({
      type: "SEARCH/SET_QUERY",
      payload: { query: "" }
    });
  };
  return [$viewStore, viewStore, onInput, click_handler, click_handler_1];
}
var Search_bar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance56, create_fragment56, safe_not_equal, {}, add_css23);
  }
};
var search_bar_default = Search_bar;

// src/view/components/container/main.svelte
function add_css24(target) {
  append_styles(target, "svelte-1giyc7d", ".lineage-main.svelte-1giyc7d{--sidebar-right:50px;--z-index-breadcrumbs:10;background-color:var(--background-container);display:flex;height:100%;width:100%;position:relative}");
}
function create_if_block_14(ctx) {
  let hotkeys;
  let current;
  hotkeys = new hotkeys_default({});
  return {
    c() {
      create_component(hotkeys.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkeys, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(hotkeys.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkeys.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkeys, detaching);
    }
  };
}
function create_if_block10(ctx) {
  let filehistory;
  let current;
  filehistory = new file_histoy_default({
    props: {
      documentHistory: (
        /*$documentStore*/
        ctx[1].history
      ),
      path: (
        /*$documentStore*/
        ctx[1].file.path
      )
    }
  });
  return {
    c() {
      create_component(filehistory.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filehistory, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const filehistory_changes = {};
      if (dirty & /*$documentStore*/
      2)
        filehistory_changes.documentHistory = /*$documentStore*/
        ctx2[1].history;
      if (dirty & /*$documentStore*/
      2)
        filehistory_changes.path = /*$documentStore*/
        ctx2[1].file.path;
      filehistory.$set(filehistory_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filehistory.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filehistory.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filehistory, detaching);
    }
  };
}
function create_fragment57(ctx) {
  let div;
  let breadcrumbs;
  let t0;
  let navigationhistory;
  let t1;
  let controlsbar;
  let t2;
  let container;
  let t3;
  let current_block_type_index;
  let if_block;
  let t4;
  let searchbar;
  let div_class_value;
  let current;
  breadcrumbs = new breadcrumbs_default({});
  navigationhistory = new navigation_history_default({});
  controlsbar = new controls_bar_default({
    props: {
      documentHistory: (
        /*$documentStore*/
        ctx[1].history
      ),
      path: (
        /*$documentStore*/
        ctx[1].file.path
      )
    }
  });
  container = new container_default({});
  const if_block_creators = [create_if_block10, create_if_block_14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$viewStore*/
      ctx2[0].ui.showHistorySidebar && /*$documentStore*/
      ctx2[1].file.path
    )
      return 0;
    if (
      /*$viewStore*/
      ctx2[0].ui.showHelpSidebar
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  searchbar = new search_bar_default({});
  return {
    c() {
      div = element("div");
      create_component(breadcrumbs.$$.fragment);
      t0 = space();
      create_component(navigationhistory.$$.fragment);
      t1 = space();
      create_component(controlsbar.$$.fragment);
      t2 = space();
      create_component(container.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      create_component(searchbar.$$.fragment);
      attr(div, "class", div_class_value = null_to_empty(`lineage-main ${/*$viewStore*/
      ctx[0].search.searching ? "is-loading" : ""}`) + " svelte-1giyc7d");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(breadcrumbs, div, null);
      append(div, t0);
      mount_component(navigationhistory, div, null);
      append(div, t1);
      mount_component(controlsbar, div, null);
      append(div, t2);
      mount_component(container, div, null);
      append(div, t3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(div, t4);
      mount_component(searchbar, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const controlsbar_changes = {};
      if (dirty & /*$documentStore*/
      2)
        controlsbar_changes.documentHistory = /*$documentStore*/
        ctx2[1].history;
      if (dirty & /*$documentStore*/
      2)
        controlsbar_changes.path = /*$documentStore*/
        ctx2[1].file.path;
      controlsbar.$set(controlsbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, t4);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty & /*$viewStore*/
      1 && div_class_value !== (div_class_value = null_to_empty(`lineage-main ${/*$viewStore*/
      ctx2[0].search.searching ? "is-loading" : ""}`) + " svelte-1giyc7d")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(breadcrumbs.$$.fragment, local);
      transition_in(navigationhistory.$$.fragment, local);
      transition_in(controlsbar.$$.fragment, local);
      transition_in(container.$$.fragment, local);
      transition_in(if_block);
      transition_in(searchbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(breadcrumbs.$$.fragment, local);
      transition_out(navigationhistory.$$.fragment, local);
      transition_out(controlsbar.$$.fragment, local);
      transition_out(container.$$.fragment, local);
      transition_out(if_block);
      transition_out(searchbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(breadcrumbs);
      destroy_component(navigationhistory);
      destroy_component(controlsbar);
      destroy_component(container);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      destroy_component(searchbar);
    }
  };
}
function instance57($$self, $$props, $$invalidate) {
  let $viewStore;
  let $documentStore;
  let { plugin } = $$props;
  let { view } = $$props;
  const documentStore = view.documentStore;
  component_subscribe($$self, documentStore, (value) => $$invalidate(1, $documentStore = value));
  const viewStore = view.viewStore;
  component_subscribe($$self, viewStore, (value) => $$invalidate(0, $viewStore = value));
  setContext("plugin", plugin);
  setContext("view", view);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(4, plugin = $$props2.plugin);
    if ("view" in $$props2)
      $$invalidate(5, view = $$props2.view);
  };
  return [$viewStore, $documentStore, documentStore, viewStore, plugin, view];
}
var Main = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance57, create_fragment57, safe_not_equal, { plugin: 4, view: 5 }, add_css24);
  }
};
var main_default = Main;

// src/stores/view/helpers/find-node-column.ts
var findNodeColumn = (columns, nodeId) => {
  for (let i = 0; i < columns.length; i++) {
    const column = columns[i];
    for (const group of column.groups) {
      if (group.nodes.find((n) => n === nodeId))
        return i;
    }
  }
  return -1;
};

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id2 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    id2 += urlAlphabet[bytes[size] & 63];
  }
  return id2;
};

// src/helpers/id.ts
var id_size = 3;
var id = {
  rootNode: () => "r" + nanoid(id_size),
  node: () => "n" + nanoid(id_size),
  column: () => "c" + nanoid(id_size),
  snapshot: () => "s" + nanoid(id_size)
};

// src/stores/document/reducers/move-node/helpers/sort-groups.ts
var sortGroups = (parents, children2) => {
  const parentsIndices = Object.fromEntries(
    parents.map((x) => x.nodes).flat().map((x, i) => [x, i])
  );
  return children2.sort((a, b) => {
    return parentsIndices[a.parentId] - parentsIndices[b.parentId];
  });
};

// src/stores/document/reducers/insert-node/helpers/insert-child.ts
var insertChild = (columns, nodeIdOfParent, newNodeId) => {
  const parentColumnIndex = findNodeColumn(columns, nodeIdOfParent);
  let createdNode = null;
  if (parentColumnIndex === -1) {
    throw new Error("could not find parent column");
  }
  const childColumnIndex = parentColumnIndex + 1;
  createdNode = newNodeId;
  if (columns[childColumnIndex]) {
    const childColumn = columns[childColumnIndex];
    const childGroup = childColumn.groups.find(
      (g) => g.parentId === nodeIdOfParent
    );
    if (childGroup) {
      childGroup.nodes.push(createdNode);
    } else {
      childColumn.groups.push({
        nodes: [createdNode],
        parentId: nodeIdOfParent
      });
    }
    childColumn.groups = sortGroups(
      columns[parentColumnIndex].groups,
      childColumn.groups
    );
  } else {
    columns.push({
      id: id.column(),
      groups: [
        {
          nodes: [createdNode],
          parentId: nodeIdOfParent
        }
      ]
    });
  }
};

// src/stores/view/helpers/search/find-group-by-node-id.ts
var findGroupByNodeId = (columns, nodeId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      for (const _nodeId of group.nodes) {
        if (_nodeId === nodeId)
          return group;
      }
    }
  }
};
var findGroupByParentId = (columns, parentId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      if (group.parentId === parentId) {
        return { group, column };
      }
    }
  }
};

// src/stores/document/reducers/insert-node/insert-node.ts
var insertNode = (columns, content, action) => {
  const payload = action.payload;
  invariant(payload.activeNodeId);
  const newNodeId = id.node();
  if (payload.position === "right") {
    insertChild(columns, payload.activeNodeId, newNodeId);
  } else {
    const columnIndex = findNodeColumn(columns, payload.activeNodeId);
    const column = columns[columnIndex];
    const group = findGroupByNodeId([column], payload.activeNodeId);
    invariant(group, "could not find group of " + payload.activeNodeId);
    const groupIndex = group.nodes.findIndex(
      (c) => c === payload.activeNodeId
    );
    if (columnIndex === -1 || groupIndex === -1)
      throw new Error("could not find node index");
    const insertionIndex = action.payload.position === "up" ? groupIndex : groupIndex + 1;
    group.nodes.splice(insertionIndex, 0, newNodeId);
  }
  content[newNodeId] = action.payload.content ? {
    content: action.payload.content
  } : null;
  return newNodeId;
};

// src/stores/view/helpers/create-node.ts
var createNode = (__nodeId__) => __nodeId__ || id.node();
var createColumn = () => ({
  id: id.column(),
  groups: []
});
var createGroup = (parentId) => ({
  nodes: [],
  parentId
});

// src/stores/view/helpers/search/find-child-group.ts
var findChildGroup = (columns, node) => {
  for (const column of columns) {
    for (const group of column.groups) {
      if (group.parentId === node) {
        return group;
      }
    }
  }
};

// src/stores/document/reducers/move-node/helpers/move-node-as-child.ts
var moveNodeAsChild = (columns, node, targetNode) => {
  const targetGroup = findChildGroup(columns, targetNode);
  if (targetGroup) {
    targetGroup.nodes.push(node);
  } else {
    const currentColumnIndex = findNodeColumn(columns, targetNode);
    let targetColumn;
    targetColumn = columns[currentColumnIndex + 1];
    if (!targetColumn) {
      const newColumn = createColumn();
      columns.push(newColumn);
      targetColumn = newColumn;
    }
    const newGroup = createGroup(targetNode);
    newGroup.nodes.push(node);
    targetColumn.groups.push(newGroup);
  }
};

// src/stores/document/reducers/move-node/helpers/move-node-as-sibling.ts
var moveNodeAsSibling = (columns, direction, node, targetNode) => {
  const targetGroup = findGroupByNodeId(columns, targetNode);
  if (targetGroup) {
    const index = targetGroup.nodes.findIndex((n) => n === targetNode);
    const insertionIndex = direction === "up" ? index : index + 1;
    targetGroup.nodes.splice(insertionIndex, 0, node);
  }
};

// src/stores/document/reducers/move-node/helpers/move-child-groups/remove-child-groups-from-their-columns.ts
var removeChildGroupsFromTheirColumns = (columns, currentParentNode) => {
  const childGroupsArray = [];
  traverseDown(childGroupsArray, columns, currentParentNode);
  const childGroups = new Set(childGroupsArray);
  const sortedChildGroups = [];
  for (const column of columns) {
    const removedGroups = [];
    const groups = [];
    for (const group of column.groups) {
      if (childGroups.has(group.parentId)) {
        removedGroups.push(group);
      } else {
        groups.push(group);
      }
    }
    column.groups = groups;
    if (removedGroups.length > 0)
      sortedChildGroups.push(removedGroups);
  }
  return sortedChildGroups;
};

// src/stores/document/reducers/move-node/helpers/move-child-groups/move-child-groups-next-to-their-parent.ts
var moveChildGroupsNextToTheirParent = (columns, parentNode) => {
  const sortedChildGroups = removeChildGroupsFromTheirColumns(
    columns,
    parentNode
  );
  const parentColumnIndex = findNodeColumn(columns, parentNode);
  for (let i = 0; i < sortedChildGroups.length; i++) {
    const groups = sortedChildGroups[i];
    for (const group of groups) {
      const targetColumnIndex = parentColumnIndex + 1 + i;
      if (!columns[targetColumnIndex]) {
        columns.push({
          id: id.column(),
          groups: []
        });
      }
      columns[targetColumnIndex].groups.push(group);
    }
  }
};

// src/stores/document/reducers/move-node/helpers/remove-node-from-group.ts
var removeNodeFromGroup = (columns, node) => {
  const currentGroup = findGroupByNodeId(columns, node);
  if (currentGroup) {
    currentGroup.nodes = currentGroup.nodes.filter((n) => n !== node);
  }
};

// src/stores/document/reducers/move-node/helpers/change-node-position.ts
var changeNodePosition = (columns, node, targetNode, direction) => {
  removeNodeFromGroup(columns, node);
  if (direction === "right") {
    moveNodeAsChild(columns, node, targetNode);
  } else {
    moveNodeAsSibling(
      columns,
      direction === "left" ? "down" : direction,
      node,
      targetNode
    );
  }
  moveChildGroupsNextToTheirParent(columns, node);
};

// src/stores/document/reducers/move-node/helpers/clean-and-sort-columns.ts
var cleanAndSortColumns = (columns) => {
  const emptyColumns = /* @__PURE__ */ new Set();
  for (let i = 1; i < columns.length; i++) {
    const column = columns[i];
    column.groups = column.groups.filter((g) => g.nodes.length > 0);
    if (column.groups.length === 0) {
      emptyColumns.add(column.id);
    }
  }
  for (const emptyColumn of emptyColumns) {
    const i = columns.findIndex((c) => c.id === emptyColumn);
    if (i > 0)
      columns.splice(i, 1);
  }
  for (let i = 1; i < columns.length; i++) {
    const column = columns[i];
    if (column.groups.length) {
      const previousColumn = columns[i - 1];
      if (column.groups.length > 0) {
        column.groups = sortGroups(
          previousColumn.groups,
          column.groups
        );
      }
    }
  }
};

// src/stores/document/reducers/drop-node/drop-node.ts
var dropNode = (columns, action) => {
  const droppedNode = action.payload.droppedNodeId;
  const targetNode = action.payload.targetNodeId;
  invariant(droppedNode);
  invariant(targetNode);
  changeNodePosition(
    columns,
    droppedNode,
    targetNode,
    action.payload.position
  );
  cleanAndSortColumns(columns);
};

// src/stores/view/helpers/json-to-md/json-to-columns/json-tree-to-columns.ts
var groupsCache = {};
var findGroup = (column, parentId) => {
  if (!groupsCache[parentId]) {
    groupsCache[parentId] = column.groups.find(
      (g) => g.parentId === parentId
    );
  }
  return groupsCache[parentId];
};
var jsonTreeToColumns = (tree, parentId = id.rootNode(), columns = [], content = {}, level2 = 0) => {
  for (const treeNode of tree) {
    const node = id.node();
    content[node] = {
      content: treeNode.content
    };
    if (!columns[level2]) {
      columns.push(createColumn());
    }
    const column = columns[level2];
    let group;
    group = findGroup(column, parentId);
    if (!group) {
      group = createGroup(parentId);
      column.groups.push(group);
    }
    group.nodes.push(node);
    if (treeNode.children.length > 0) {
      jsonTreeToColumns(
        treeNode.children,
        node,
        columns,
        content,
        level2 + 1
      );
    }
  }
  return { content, columns };
};

// src/stores/view/helpers/json-to-md/markdown-to-json/markdown-to-json.ts
var depthLevel = (number) => {
  if (number.includes(".")) {
    return number.split(".").length;
  } else
    return /\d+/.test(number) ? 1 : 0;
};
var trimCurrentNode = (node) => {
  if (node) {
    node.content = node.content.trim();
  }
};
var markdownToJson = (text2) => {
  const lines = text2.split("\n");
  const map = {};
  const tree = [];
  let currentNode = null;
  let currentParentNumber = "";
  for (const line of lines) {
    const sectionNumber = parseDelimiter(line);
    if (sectionNumber) {
      const [parent, , full] = sectionNumber;
      const isASibling = parent === currentParentNumber;
      const newNode = {
        content: "",
        children: []
      };
      map[full] = newNode;
      if (isASibling) {
        if (currentNode)
          trimCurrentNode(currentNode);
        const parentNode = map[parent];
        if (parentNode) {
          parentNode.children.push(newNode);
        } else {
          tree.push(newNode);
        }
        currentNode = newNode;
      } else {
        const isChild = depthLevel(parent) > depthLevel(currentParentNumber);
        if (isChild) {
          if (!currentNode) {
            throw new Error(`could not find parent of ${full}`);
          }
          trimCurrentNode(currentNode);
          currentNode.children.push(newNode);
          currentNode = newNode;
        } else {
          if (!parent) {
            if (currentNode)
              trimCurrentNode(currentNode);
            tree.push(newNode);
            currentNode = newNode;
          } else {
            const parentNode = map[parent];
            if (!parentNode) {
              throw new Error(`could not find parent of ${full}`);
            }
            if (currentNode)
              trimCurrentNode(currentNode);
            parentNode.children.push(newNode);
            currentNode = newNode;
          }
        }
      }
      currentParentNumber = parent;
    } else {
      if (currentNode) {
        if (currentNode.content)
          currentNode.content += "\n";
        currentNode.content += line;
      } else if (line.trim()) {
        currentNode = {
          content: line,
          children: []
        };
        tree.push(currentNode);
      }
    }
  }
  return tree;
};

// src/stores/document/reducers/load-document-from-file/helpers/create-first-node.ts
var createFirstNode = (columns, content) => {
  if (columns.length === 0) {
    const rootId = id.rootNode();
    const createdNode = createNode();
    content[createdNode] = null;
    columns.push({
      id: id.column(),
      groups: [
        {
          parentId: rootId,
          nodes: [createdNode]
        }
      ]
    });
  }
};

// src/stores/document/reducers/load-document-from-file/load-document-from-file.ts
var loadDocumentFromFile = (state, action) => {
  const tree = markdownToJson(action.payload.document.data);
  const document2 = jsonTreeToColumns(tree);
  state.document.columns = document2.columns;
  state.document.content = document2.content;
  const emptyTree = tree.length === 0;
  if (emptyTree) {
    createFirstNode(state.document.columns, state.document.content);
  }
  if (action.type === "DOCUMENT/LOAD_FILE")
    state.file.frontmatter = action.payload.document.frontmatter;
  const activeNode = state.document.columns[0].groups[0].nodes[0];
  invariant(activeNode);
  return activeNode;
};

// src/stores/view/helpers/errors.ts
var SilentError = class extends Error {
};

// src/stores/document/reducers/content/set-node-content.ts
var setNodeContent = (content, action) => {
  const nodeContent = content[action.payload.nodeId];
  const contentString = nodeContent?.content || "";
  if (contentString === action.payload.content)
    throw new SilentError("identical content");
  const nodeId = action.payload.nodeId;
  if (!nodeContent)
    content[nodeId] = { content: action.payload.content };
  else
    nodeContent.content = action.payload.content;
};

// src/stores/document/reducers/delete-node/helpers/delete-groups-by-parent-id.ts
var deleteGroupsByParentId = (columns, content, parentIds) => {
  for (const column of columns) {
    const groups = [];
    for (const group of column.groups) {
      if (parentIds.has(group.parentId)) {
        for (const node of group.nodes) {
          delete content[node];
        }
      } else {
        groups.push(group);
      }
    }
    column.groups = groups;
  }
};

// src/stores/document/reducers/delete-node/helpers/delete-node-by-id.ts
var deleteNodeById = (columns, content, nodeId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      for (let i = 0; i < group.nodes.length; i++) {
        const _nodeId = group.nodes[i];
        if (_nodeId === nodeId) {
          group.nodes.splice(i, 1);
          delete content[_nodeId];
          return;
        }
      }
    }
  }
};

// src/stores/document/reducers/delete-node/helpers/delete-branch.ts
var deleteBranch = (columns, content, node) => {
  const childGroups = [];
  traverseDown(childGroups, columns, node);
  if (childGroups.length > 0)
    deleteGroupsByParentId(columns, content, new Set(childGroups));
  deleteNodeById(columns, content, node);
};

// src/stores/document/reducers/delete-node/helpers/is-last-root-node.ts
var isLastRootNode = (columns, node) => {
  const column = columns[0];
  if (node && column.groups.length === 1) {
    const group = column.groups[0];
    if (group.nodes.length === 1 && group.nodes[0] === node)
      return true;
  }
  return false;
};

// src/stores/view/reducers/document/helpers/find-next-node/find-next-node-after-deletion.ts
var findNextNodeAfterDeletion = (columns, node) => {
  let nextNode = null;
  const group = findGroupByNodeId(columns, node);
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  if (group) {
    const nodeIndex = group.nodes.findIndex((n) => n === node);
    if (nodeIndex === 0)
      nextNode = group.nodes[1];
    else if (nodeIndex > 0)
      nextNode = group.nodes[nodeIndex - 1];
    else
      nextNode = group.nodes[group.nodes.length - 1];
  }
  if (!nextNode) {
    if (group && columnIndex > 0)
      nextNode = group?.parentId;
    else
      nextNode = column.groups[0].nodes[0];
  }
  return nextNode;
};

// src/stores/view/reducers/document/helpers/find-next-node/find-next-active-node-on-keyboard-navigation.ts
var findNextActiveNodeOnKeyboardNavigation = (columns, node, direction) => {
  if (!node)
    return;
  let nextNode = null;
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  if (!column)
    return;
  if (direction === "left") {
    const group = findGroupByNodeId(columns, node);
    if (group && !group.parentId.startsWith("r"))
      nextNode = group.parentId;
  } else if (direction === "right") {
    const group = findChildGroup(columns, node);
    if (group) {
      nextNode = group.nodes[0];
    }
  } else {
    const allNodes = column.groups.map((g) => g.nodes).flat();
    const nodeIndex = allNodes.findIndex((n) => n === node);
    if (direction === "up") {
      if (nodeIndex > 0) {
        nextNode = allNodes[nodeIndex - 1];
      }
    } else if (direction === "down") {
      if (nodeIndex < allNodes.length - 1) {
        nextNode = allNodes[nodeIndex + 1];
      }
    }
  }
  return nextNode;
};

// src/stores/view/reducers/document/helpers/find-next-node/find-node-to-jump-to.ts
var findNodeToJumpTo = (columns, node, target) => {
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  if (target === "start-of-column") {
    return column.groups[0].nodes[0];
  } else if (target === "end-of-column") {
    const nodeGroup = column.groups[column.groups.length - 1];
    return nodeGroup.nodes[nodeGroup.nodes.length - 1];
  } else {
    const group = column.groups.find((g) => g.nodes.includes(node));
    if (group) {
      if (target === "start-of-group")
        return group.nodes[0];
      else if (target === "end-of-group") {
        return group.nodes[group.nodes.length - 1];
      }
    }
  }
};

// src/stores/view/reducers/document/helpers/find-next-node/find-next-active-node.ts
var findNextActiveNode = (columns, node, action) => {
  if (action.type === "DOCUMENT/DELETE_NODE") {
    return findNextNodeAfterDeletion(columns, node);
  } else if (action.type === "DOCUMENT/NAVIGATE_USING_KEYBOARD") {
    return findNextActiveNodeOnKeyboardNavigation(
      columns,
      node,
      action.payload.direction
    );
  } else if (action.type === "DOCUMENT/JUMP_TO_NODE") {
    return findNodeToJumpTo(columns, node, action.payload.target);
  }
};

// src/stores/document/reducers/delete-node/delete-node.ts
var deleteNode = (columns, content, nodeId) => {
  invariant(nodeId);
  const lastNode = isLastRootNode(columns, nodeId);
  if (lastNode)
    throw new Error("cannot delete last node");
  const nextNode = findNextActiveNode(columns, nodeId, {
    type: "DOCUMENT/DELETE_NODE",
    payload: {
      activeNodeId: nodeId
    }
  });
  if (!nextNode)
    throw new Error("could not find next node");
  deleteBranch(columns, content, nodeId);
  cleanAndSortColumns(columns);
  return nextNode;
};

// src/stores/document/reducers/move-node/helpers/find-adjacent-sibling-node.ts
var findAdjacentSiblingNode = (columns, node, direction) => {
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  const flatColumn = column.groups.map((g) => g.nodes).flat();
  const nodeIndex = flatColumn.findIndex((n) => n === node);
  return flatColumn[nodeIndex + (direction === "up" ? -1 : 1)];
};

// src/stores/document/reducers/move-node/helpers/find-adjacent-node.ts
var findAdjacentNode = (columns, activeNodeId, direction) => {
  let targetNode = null;
  const nodeToMove = activeNodeId;
  if (direction === "left") {
    const group = findGroupByNodeId(columns, nodeToMove);
    if (group && !group.parentId.startsWith("r"))
      targetNode = group.parentId;
  } else {
    targetNode = findAdjacentSiblingNode(
      columns,
      nodeToMove,
      direction === "right" ? "up" : direction
    );
  }
  if (!targetNode && direction === "right") {
    const columnIndex = findNodeColumn(columns, nodeToMove);
    const isFirstNodeOfColumn = columns[columnIndex].groups[0]?.nodes[0] === nodeToMove;
    if (isFirstNodeOfColumn) {
      targetNode = findAdjacentSiblingNode(columns, nodeToMove, "down");
    }
  }
  return targetNode;
};

// src/stores/document/reducers/move-node/move-node.ts
var moveNode2 = (columns, action) => {
  const nodeToMove = action.payload.activeNodeId;
  invariant(nodeToMove);
  const targetNode = findAdjacentNode(
    columns,
    nodeToMove,
    action.payload.direction
  );
  if (!targetNode)
    throw new SilentError("could not find adjacent node");
  changeNodePosition(
    columns,
    nodeToMove,
    targetNode,
    action.payload.direction
  );
  cleanAndSortColumns(columns);
};

// src/stores/document/reducers/move-node/helpers/move-child-groups/move-orphan-groups-to-a-new-parent.ts
var moveOrphanGroupsToANewParent = (columns, currentParentNode, newParentNode, direction) => {
  const groupOfMergedNode = findGroupByParentId(columns, currentParentNode);
  if (!groupOfMergedNode)
    return;
  groupOfMergedNode.column.groups = groupOfMergedNode.column.groups.filter(
    (g) => g.parentId !== groupOfMergedNode.group.parentId
  );
  const parentColumnIndex = findNodeColumn(columns, newParentNode);
  const targetColumnIndex = parentColumnIndex + 1;
  const existingGroupOfNewParent = findGroupByParentId(
    columns,
    newParentNode
  );
  if (existingGroupOfNewParent) {
    if (direction === "up")
      existingGroupOfNewParent.group.nodes.push(
        ...groupOfMergedNode.group.nodes
      );
    else {
      existingGroupOfNewParent.group.nodes = [
        ...groupOfMergedNode.group.nodes,
        ...existingGroupOfNewParent.group.nodes
      ];
    }
  } else {
    if (!columns[targetColumnIndex]) {
      columns.push({
        id: id.column(),
        groups: []
      });
    }
    groupOfMergedNode.group.parentId = newParentNode;
    columns[targetColumnIndex].groups.push(groupOfMergedNode.group);
  }
};

// src/stores/document/reducers/merge-node/merge-node.ts
var mergeNode2 = (columns, content, action) => {
  const mergedNode = action.payload.activeNodeId;
  const adjacentNode = findAdjacentSiblingNode(
    columns,
    mergedNode,
    action.payload.direction
  );
  invariant(mergedNode, "merged node is undefined");
  if (!adjacentNode)
    throw new SilentError("could not find adjacent node");
  const mergedNodeContent = content[mergedNode] || { content: "" };
  const adjacentNodeContent = content[adjacentNode] || { content: "" };
  let newContent = "";
  if (action.payload.direction === "up") {
    newContent = (adjacentNodeContent.content + "\n" + mergedNodeContent.content).trim();
  } else if (action.payload.direction === "down") {
    newContent = (mergedNodeContent.content + "\n" + adjacentNodeContent.content).trim();
  }
  if (newContent) {
    const adjacentNodeContentObject = content[adjacentNode];
    if (adjacentNodeContentObject) {
      adjacentNodeContentObject.content = newContent;
    } else {
      content[adjacentNode] = { content: newContent };
    }
  }
  moveOrphanGroupsToANewParent(
    columns,
    mergedNode,
    adjacentNode,
    action.payload.direction
  );
  deleteNodeById(columns, content, mergedNode);
  cleanAndSortColumns(columns);
  return adjacentNode;
};

// src/stores/document/reducers/history/helpers/update-navigation-state.ts
var updateNavigationState = (document2) => {
  const activeIndex = document2.state.activeIndex;
  document2.state.canGoBack = activeIndex > 0;
  document2.state.canGoForward = activeIndex < document2.items.length - 1;
};

// src/stores/document/reducers/history/helpers/create-snapshot.ts
var createSnapshot = (document2, action, activeNodeId) => {
  return {
    data: {
      columns: JSON.stringify(document2.columns),
      content: JSON.stringify(document2.content),
      activeNodeId
    },
    created: Date.now(),
    id: id.snapshot(),
    action
  };
};

// src/stores/document/reducers/history/helpers/remove-old-history-items.ts
var removeOldHistoryItems = (history, MAX_ITEMS = 20) => {
  if (history.items.length >= MAX_ITEMS) {
    const numSnapshotsToRemove = history.items.length - MAX_ITEMS + 1;
    history.items.splice(0, numSnapshotsToRemove);
    const activeItem = history.items[history.state.activeIndex];
    history.state.activeIndex = history.items.findIndex(
      (item) => item === activeItem
    );
  }
};

// src/stores/document/reducers/history/helpers/remove-obsolete-history-items.ts
var removeObsoleteHistoryItems = (history) => {
  if (history.items.length > 0 && history.state.activeIndex !== history.items.length - 1) {
    history.items.splice(history.state.activeIndex + 1);
  }
};

// src/stores/document/reducers/history/add-snapshot.ts
var addSnapshot = (document2, history, action, activeNodeId) => {
  const items = history.items;
  const activeIndex = history.state.activeIndex;
  const activeSnapshot = items[activeIndex];
  removeObsoleteHistoryItems(history);
  removeOldHistoryItems(history);
  if (activeSnapshot && action.type === "DOCUMENT/LOAD_FILE") {
    const snapshotContent = JSON.stringify(
      Object.values(JSON.parse(activeSnapshot.data.content))
    );
    const documentContent = JSON.stringify(Object.values(document2.content));
    if (snapshotContent === documentContent) {
      history.items.splice(history.state.activeIndex, 1);
    }
  }
  if (action.type !== "DOCUMENT/INSERT_NODE" && activeSnapshot) {
    activeSnapshot.data.activeNodeId = activeNodeId;
  }
  const snapshot = createSnapshot(document2, action, activeNodeId);
  items.push(snapshot);
  history.state.activeIndex = items.length - 1;
  history.context.activeNodeId = activeNodeId;
  updateNavigationState(history);
};

// src/stores/document/reducers/history/helpers/find-snapshot-index.ts
var findSnapshotIndex = (snapshots, id2) => {
  if (!id2)
    return -1;
  return snapshots.findIndex((snapshot) => snapshot.id === id2);
};

// src/stores/document/reducers/history/helpers/load-document-from-snapshot.ts
var loadDocumentFromSnapshot = (document2, snapshot, history) => {
  history.context.activeNodeId = snapshot.data.activeNodeId;
  document2.content = JSON.parse(snapshot.data.content);
  document2.columns = JSON.parse(snapshot.data.columns);
};

// src/stores/document/reducers/history/select-snapshot.ts
var selectSnapshot = (document2, history, action) => {
  const index = findSnapshotIndex(history.items, action.payload.snapshotId);
  if (index !== -1) {
    history.state.activeIndex = index;
    updateNavigationState(history);
    const snapshot = history.items[index];
    loadDocumentFromSnapshot(document2, snapshot, history);
  }
};

// src/stores/document/reducers/history/undo-action.ts
var undoAction = (document2, history) => {
  const currentIndex = history.state.activeIndex;
  const newIndex = currentIndex - 1;
  const snapshot = history.items[newIndex];
  if (!snapshot)
    return;
  history.state.activeIndex = newIndex;
  updateNavigationState(history);
  loadDocumentFromSnapshot(document2, snapshot, history);
};

// src/stores/view/helpers/get-document-event-type.ts
var contentEvents = /* @__PURE__ */ new Set(["DOCUMENT/SET_NODE_CONTENT"]);
var creationAndDeletionEvents = /* @__PURE__ */ new Set([
  "DOCUMENT/INSERT_NODE",
  "DOCUMENT/DELETE_NODE",
  "DOCUMENT/MERGE_NODE",
  "DOCUMENT/LOAD_FILE"
]);
var shapeEvents = /* @__PURE__ */ new Set([
  "DOCUMENT/DROP_NODE",
  "DOCUMENT/MOVE_NODE"
]);
var historyEvents = /* @__PURE__ */ new Set([
  "HISTORY/APPLY_NEXT_SNAPSHOT",
  "HISTORY/APPLY_PREVIOUS_SNAPSHOT",
  "HISTORY/SELECT_SNAPSHOT"
]);
var cachedResults = {};
var getDocumentEventType = (type) => {
  if (cachedResults[type]) {
    return cachedResults[type];
  }
  let result = null;
  if (contentEvents.has(type))
    result = { content: true };
  else if (creationAndDeletionEvents.has(type))
    result = { creationAndDeletion: true };
  else if (shapeEvents.has(type))
    result = { shape: true };
  else if (historyEvents.has(type))
    result = { changeHistory: true };
  if (!result)
    result = {};
  cachedResults[type] = result;
  return result;
};

// src/stores/document/reducers/history/redo-action.ts
var redoAction = (document2, history) => {
  const currentIndex = history.state.activeIndex;
  const nexIndex = currentIndex + 1;
  const snapshot = history.items[nexIndex];
  if (!snapshot)
    return;
  history.state.activeIndex = nexIndex;
  updateNavigationState(history);
  loadDocumentFromSnapshot(document2, snapshot, history);
};

// src/stores/document/default-document-state.ts
var defaultDocumentState = () => ({
  document: {
    columns: [],
    content: {}
  },
  file: {
    path: null,
    frontmatter: ""
  },
  history: {
    items: [],
    state: {
      activeIndex: -1,
      canGoBack: false,
      canGoForward: false
    },
    context: {
      activeNodeId: ""
    }
  }
});

// src/stores/document/document-reducer.ts
var updateDocumentState = (state, action) => {
  let activeNodeId = null;
  if (action.type === "DOCUMENT/SET_NODE_CONTENT") {
    setNodeContent(state.document.content, action);
    activeNodeId = action.payload.nodeId;
  } else if (action.type === "DOCUMENT/INSERT_NODE") {
    activeNodeId = insertNode(
      state.document.columns,
      state.document.content,
      action
    );
  } else if (action.type === "DOCUMENT/DELETE_NODE") {
    activeNodeId = deleteNode(
      state.document.columns,
      state.document.content,
      action.payload.activeNodeId
    );
  } else if (action.type === "DOCUMENT/DROP_NODE") {
    dropNode(state.document.columns, action);
    activeNodeId = action.payload.droppedNodeId;
  } else if (action.type === "DOCUMENT/MOVE_NODE") {
    moveNode2(state.document.columns, action);
    activeNodeId = action.payload.activeNodeId;
  } else if (action.type === "DOCUMENT/MERGE_NODE") {
    activeNodeId = mergeNode2(
      state.document.columns,
      state.document.content,
      action
    );
  } else if (action.type === "DOCUMENT/LOAD_FILE") {
    activeNodeId = loadDocumentFromFile(state, action);
  } else if (action.type === "RESET_STORE") {
    const newState = defaultDocumentState();
    state.document = newState.document;
    state.history = newState.history;
    state.file = newState.file;
  } else if (action.type === "HISTORY/SELECT_SNAPSHOT") {
    selectSnapshot(state.document, state.history, action);
  } else if (action.type === "HISTORY/APPLY_PREVIOUS_SNAPSHOT") {
    undoAction(state.document, state.history);
  } else if (action.type === "HISTORY/APPLY_NEXT_SNAPSHOT") {
    redoAction(state.document, state.history);
  } else if (action.type === "FS/SET_FILE_PATH") {
    state.file.path = action.payload.path;
  }
  const eventType = getDocumentEventType(action.type);
  const contentShapeCreation = eventType.content || eventType.shape || eventType.creationAndDeletion;
  if (activeNodeId && contentShapeCreation) {
    addSnapshot(
      state.document,
      state.history,
      action,
      activeNodeId
    );
  }
};
var documentReducer = (store, action) => {
  updateDocumentState(store, action);
  return store;
};

// src/stores/view/helpers/json-to-md/columns-to-json/columns-to-json-tree.ts
var createTreeNode = (content = "") => {
  return {
    content: content.trim(),
    children: []
  };
};
var columnsToJsonTree = (columns, content) => {
  const nodeMap = {};
  for (const column of columns) {
    for (const group of column.groups) {
      for (const node of group.nodes) {
        const treeNode = createTreeNode(content[node]?.content);
        let parentNode = nodeMap[group.parentId];
        if (!parentNode) {
          parentNode = createTreeNode();
          nodeMap[group.parentId] = parentNode;
        }
        parentNode.children.push(treeNode);
        nodeMap[node] = treeNode;
      }
    }
  }
  const roots = [];
  if (columns[0])
    for (const group of columns[0].groups) {
      for (const node of group.nodes) {
        const treeNode = nodeMap[node];
        if (treeNode) {
          roots.push(treeNode);
        } else {
          throw new Error(`could not find node ${node}`);
        }
      }
    }
  return roots;
};

// src/stores/view/helpers/json-to-md/json-to-makdown/json-to-markdown.ts
var jsonToMarkdown = (tree, parentNumber = "", text2 = "", includeStructure = true) => {
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    const content = node.content;
    const index = i + 1;
    if (text2)
      text2 = text2 + (includeStructure ? "\n" : "\n\n");
    if (includeStructure) {
      text2 += delimiter(parentNumber, index) + "\n" + content;
    } else {
      text2 += content;
    }
    if (node.children.length > 0) {
      text2 = jsonToMarkdown(
        node.children,
        level(parentNumber, index),
        text2,
        includeStructure
      );
    }
  }
  return text2;
};

// src/view/helpers/stores-cache.ts
var deletePath = (oldPath) => {
  if (oldPath in stores) {
    const oldEntry = stores[oldPath];
    oldEntry.dispatch({
      type: "RESET_STORE"
    });
    delete stores[oldPath];
  }
};
var updatePath = (oldPath, newPath) => {
  if (oldPath in stores) {
    const oldEntry = stores[oldPath];
    delete stores[oldPath];
    stores[newPath] = oldEntry;
    oldEntry.dispatch({
      type: "FS/SET_FILE_PATH",
      payload: {
        path: newPath
      }
    });
  }
};
var stores = {};

// src/helpers/clone.ts
var clone = (object) => JSON.parse(JSON.stringify(object));

// src/view/helpers/extract-frontmatter.ts
var extractFrontmatter = (markdown) => {
  const frontmatterRegex = /^---\n([\s\S]+?)\n---\n/;
  const match = markdown.match(frontmatterRegex);
  if (match) {
    const frontmatter = match[0];
    const data = markdown.slice(frontmatter.length);
    return { data, frontmatter: frontmatter.trim() };
  } else {
    return { data: markdown, frontmatter: "" };
  }
};

// src/stores/view/default-view-state.ts
var defaultViewState = () => ({
  search: {
    query: "",
    results: /* @__PURE__ */ new Set(),
    searching: false,
    showInput: false
  },
  ui: {
    showHistorySidebar: false,
    showHelpSidebar: false,
    zoomLevel: 1
  },
  document: {
    treeIndex: {},
    editing: {
      activeNodeId: ""
    },
    activeBranch: {
      group: "",
      childGroups: /* @__PURE__ */ new Set(),
      sortedParentNodes: [],
      column: ""
    },
    dnd: {
      node: "",
      childGroups: /* @__PURE__ */ new Set()
    },
    activeNode: ""
  },
  navigationHistory: {
    items: [],
    state: {
      activeIndex: -1,
      canGoBack: false,
      canGoForward: false
    },
    context: void 0
  }
});

// src/stores/view/reducers/search/set-search-query.ts
var setSearchQuery = (state, query) => {
  state.search.query = query;
  state.search.results = /* @__PURE__ */ new Set();
  state.search.searching = query.length > 0;
};

// src/stores/view/reducers/search/set-search-results.ts
var setSearchResults = (state, results) => {
  state.search.results = new Set(results);
  state.search.searching = false;
};

// src/stores/view/reducers/search/toggle-search-input.ts
var toggleSearchInput = (state) => {
  state.search.showInput = !state.search.showInput;
  if (!state.search.showInput) {
    setSearchQuery(state, "");
  }
};

// src/stores/view/reducers/ui/set-tree-index.ts
var setTreeIndex = (document2, treeIndex) => {
  document2.treeIndex = treeIndex;
};

// src/stores/view/reducers/document/enable-edit-mode.ts
var enableEditMode = (editing, action) => {
  editing.activeNodeId = action.payload.nodeId;
};

// src/stores/view/reducers/document/disable-edit-mode.ts
var disableEditMode = (editing) => {
  editing.activeNodeId = "";
};

// src/stores/view/reducers/document/on-drag-start.ts
var onDragStart = (state, action) => {
  const node = action.payload.nodeId;
  if (node) {
    state.node = action.payload.nodeId;
    state.childGroups = new Set(action.payload.childGroups);
  }
};

// src/stores/view/reducers/document/on-drag-end.ts
var onDragEnd = (state) => {
  state.node = "";
  state.childGroups = /* @__PURE__ */ new Set();
};

// src/stores/view/helpers/search/traverse-up.ts
var traverseUp = (columns, node) => {
  const parents = [];
  const nodeColumnIndex = findNodeColumn(columns, node);
  if (nodeColumnIndex > 0) {
    const group = findGroupByNodeId(columns, node);
    if (group) {
      let currentParentId = group.parentId;
      for (let i = nodeColumnIndex - 1; i >= 0; i--) {
        const column = columns[i];
        for (const group2 of column.groups) {
          if (!currentParentId)
            currentParentId = group2.parentId;
          const parentIndex = group2.nodes.findIndex(
            (n) => n === currentParentId
          );
          if (parentIndex !== -1) {
            const parent = group2.nodes[parentIndex];
            parents.push(parent);
            currentParentId = group2.parentId;
            break;
          }
        }
      }
    }
  }
  return parents;
};

// src/stores/view/reducers/document/helpers/update-active-branch.ts
var updateActiveBranch = (activeBranch, activeNodeId, columns) => {
  if (!activeNodeId)
    return;
  const sortedParents = traverseUp(columns, activeNodeId);
  const childGroups = [];
  traverseDown(childGroups, columns, activeNodeId);
  const group = findGroupByNodeId(columns, activeNodeId);
  if (!group)
    throw new Error("could not find group for node " + activeNodeId);
  activeBranch.childGroups = new Set(childGroups);
  activeBranch.sortedParentNodes = sortedParents.reverse();
  activeBranch.group = group.parentId;
  activeBranch.column = columns[findNodeColumn(columns, activeNodeId)].id;
};

// src/stores/view/reducers/ui/helpers/add-navigation-history-item.ts
var addNavigationHistoryItem = (history, nodeId) => {
  if (!nodeId)
    return;
  removeObsoleteHistoryItems(history);
  removeOldHistoryItems(history, 100);
  const activeItem = history.items[history.items.length - 1];
  if (activeItem !== nodeId) {
    history.items.push(nodeId);
  }
  history.state.activeIndex = history.items.length - 1;
  updateNavigationState(history);
};

// src/stores/view/reducers/document/helpers/update-active-node.ts
var updateActiveNode = (state, nodeId, navigationHistory) => {
  state.activeNode = nodeId;
  if (navigationHistory)
    addNavigationHistoryItem(navigationHistory, state.activeNode);
  if (state.editing.activeNodeId && state.editing.activeNodeId !== nodeId)
    state.editing.activeNodeId = "";
};

// src/stores/view/reducers/document/navigate-using-keyboard.ts
var navigateUsingKeyboard = (state, navigationHistory, action) => {
  const nextNode = findNextActiveNode(
    action.payload.columns,
    state.activeNode,
    action
  );
  if (nextNode) {
    updateActiveNode(state, nextNode, navigationHistory);
  }
};

// src/stores/view/reducers/ui/navigate-active-node.ts
var navigateActiveNode = (state, navigation, forward = false) => {
  const activeIndex = navigation.state.activeIndex;
  const newIndex = forward ? activeIndex + 1 : activeIndex - 1;
  const newItem = navigation.items[newIndex];
  if (newItem) {
    navigation.state.activeIndex = newIndex;
    updateNavigationState(navigation);
    updateActiveNode(state, newItem, null);
  }
};

// src/stores/view/reducers/document/jump-to-node.ts
var jumpToNode = (state, navigationHistory, action) => {
  const nextNode = findNextActiveNode(
    action.payload.columns,
    state.activeNode,
    action
  );
  if (nextNode) {
    updateActiveNode(state, nextNode, navigationHistory);
  }
};

// src/stores/view/reducers/ui/helpers/remove-deleted-navigation-items.ts
var removeDeletedNavigationItems = (history, content) => {
  const items = [];
  let previous = null;
  for (const item of history.items) {
    if (content.hasOwnProperty(item) && item !== previous) {
      items.push(item);
      previous = item;
    }
  }
  history.items = items;
  history.state.activeIndex = history.items.length - 1;
  updateNavigationState(history);
};

// src/stores/view/view-reducer.ts
var updateDocumentState2 = (state, action) => {
  if (action.type === "DOCUMENT/SET_ACTIVE_NODE") {
    updateActiveNode(
      state.document,
      action.payload.id,
      state.navigationHistory
    );
  } else if (action.type === "DOCUMENT/NAVIGATE_USING_KEYBOARD") {
    navigateUsingKeyboard(state.document, state.navigationHistory, action);
  } else if (action.type === "SEARCH/SET_QUERY") {
    setSearchQuery(state, action.payload.query);
  } else if (action.type === "SEARCH/SET_RESULTS") {
    setSearchResults(state, action.payload.results);
  } else if (action.type === "SEARCH/TOGGLE_INPUT") {
    toggleSearchInput(state);
  } else if (action.type === "UI/TOGGLE_HISTORY_SIDEBAR") {
    state.ui.showHelpSidebar = false;
    state.ui.showHistorySidebar = !state.ui.showHistorySidebar;
  } else if (action.type === "UI/TOGGLE_HELP_SIDEBAR") {
    state.ui.showHistorySidebar = false;
    state.ui.showHelpSidebar = !state.ui.showHelpSidebar;
  } else if (action.type === "UI/CHANGE_ZOOM_LEVEL") {
    changeZoomLevel(state, action.payload);
  } else if (action.type === "UI/SET_TREE_INDEX") {
    setTreeIndex(state.document, action.payload.treeIndex);
  } else if (action.type === "DOCUMENT/ENABLE_EDIT_MODE") {
    enableEditMode(state.document.editing, action);
  } else if (action.type === "DOCUMENT/DISABLE_EDIT_MODE") {
    disableEditMode(state.document.editing);
  } else if (action.type === "SET_DRAG_STARTED") {
    onDragStart(state.document.dnd, action);
  } else if (action.type === "DOCUMENT/SET_DRAG_ENDED") {
    onDragEnd(state.document.dnd);
  } else if (action.type === "UPDATE_ACTIVE_BRANCH") {
    updateActiveBranch(
      state.document.activeBranch,
      state.document.activeNode,
      action.payload.columns
    );
  } else if (action.type === "NAVIGATION/NAVIGATE_FORWARD") {
    navigateActiveNode(state.document, state.navigationHistory, true);
  } else if (action.type === "NAVIGATION/NAVIGATE_BACK") {
    navigateActiveNode(state.document, state.navigationHistory);
  } else if (action.type === "DOCUMENT/JUMP_TO_NODE") {
    jumpToNode(state.document, state.navigationHistory, action);
  } else if (action.type === "NAVIGATION/REMOVE_OBSOLETE") {
    removeDeletedNavigationItems(
      state.navigationHistory,
      action.payload.content
    );
  }
};
var viewReducer = (store, action) => {
  updateDocumentState2(store, action);
  return store;
};

// src/stores/view/helpers/get-view-event-type.ts
var navigationEvents = /* @__PURE__ */ new Set([
  "NAVIGATION/NAVIGATE_BACK",
  "NAVIGATION/NAVIGATE_FORWARD"
]);
var searchEvents = /* @__PURE__ */ new Set([
  "SEARCH/SET_QUERY",
  "SEARCH/SET_RESULTS"
]);
var zoomEvents = /* @__PURE__ */ new Set(["UI/CHANGE_ZOOM_LEVEL"]);
var stateEvents = /* @__PURE__ */ new Set([
  "DOCUMENT/SET_ACTIVE_NODE",
  "DOCUMENT/NAVIGATE_USING_KEYBOARD",
  "DOCUMENT/JUMP_TO_NODE"
]);
var cachedResults2 = {};
var getViewEventType = (type) => {
  if (cachedResults2[type]) {
    return cachedResults2[type];
  }
  let result = null;
  if (navigationEvents.has(type))
    result = { activeNodeHistory: true };
  else if (stateEvents.has(type))
    result = { activeNode: true };
  else if (searchEvents.has(type))
    result = { search: true };
  else if (zoomEvents.has(type))
    result = { zoom: true };
  if (!result)
    result = {};
  cachedResults2[type] = result;
  return result;
};

// src/stores/view/subscriptions/effects/align-branch/helpers/get-combined-client-rect.ts
var getCombinedBoundingClientRect = (elements) => {
  if (elements.length === 0) {
    return new DOMRect(0, 0, 0, 0);
  }
  let combinedRect = elements[0].getBoundingClientRect();
  for (let i = 1; i < elements.length; i++) {
    const rect = elements[i].getBoundingClientRect();
    combinedRect = combineRects(combinedRect, rect);
  }
  return combinedRect;
};
var combineRects = (rect1, rect2) => {
  const left = Math.min(rect1.left, rect2.left);
  const top = Math.min(rect1.top, rect2.top);
  const right = Math.max(rect1.right, rect2.right);
  const bottom = Math.max(rect1.bottom, rect2.bottom);
  const width = right - left;
  const height = bottom - top;
  return new DOMRect(left, top, width, height);
};

// src/stores/view/subscriptions/effects/align-branch/helpers/restore-zoom.ts
var suspendZoom = (column, columns) => {
  const transform = columns.style.transform;
  columns.style.transform = "none";
  const height = column.style.height;
  column.style.height = "100vh";
  return [transform, height];
};
var restoreZoom = (column, columns, style) => {
  columns.style.transform = style[0];
  column.style.height = style[1];
};

// src/stores/view/subscriptions/effects/align-branch/helpers/align-element.ts
var alignElement = (container, elements, behavior = "smooth", mode = "vertical") => {
  if (!container)
    return;
  const isArray2 = Array.isArray(elements);
  const element2 = isArray2 ? elements[0] : elements;
  if (!element2)
    return;
  const column = element2.matchParent(".column");
  const columns = column.matchParent(".columns");
  if (column) {
    const zoomStyle = suspendZoom(column, columns);
    const elementRect = isArray2 ? getCombinedBoundingClientRect(elements) : element2.getBoundingClientRect();
    const containerRect = container.parentElement.getBoundingClientRect();
    if (mode === "vertical" || mode === "both") {
      const verticalMiddle = containerRect.height / 2;
      const scrollTop = verticalMiddle - (elementRect.top - containerRect.top + elementRect.height / 2);
      column.scrollBy({
        top: scrollTop * -1,
        behavior
      });
    }
    if (mode === "horizontal" || mode === "both") {
      const horizontalMiddle = containerRect.width / 2;
      const scrollLeft = horizontalMiddle - (elementRect.left - containerRect.left + elementRect.width / 2);
      container.scrollBy({
        left: scrollLeft * -1,
        behavior
      });
    }
    restoreZoom(column, columns, zoomStyle);
    return column.id;
  }
};

// src/stores/view/subscriptions/effects/align-branch/helpers/get-node-element.ts
var getNodeElement = (container, nodeId) => {
  return container.querySelector("#" + nodeId);
};

// src/stores/view/subscriptions/effects/align-branch/align-parents-and-active-node.ts
var alignParentsAndActiveNode = (documentState, viewState, container, localState, behavior) => {
  const group = viewState.document.activeBranch.group;
  lastActiveNodeOfGroups[viewState.document.activeBranch.column] = {
    nodeId: viewState.document.activeNode,
    groupId: group
  };
  const element2 = getNodeElement(container, viewState.document.activeNode);
  if (element2) {
    const columnId = alignElement(container, element2, behavior, "both");
    if (columnId)
      localState.columns.add(columnId);
  }
  for (const id2 of viewState.document.activeBranch.sortedParentNodes) {
    const element3 = getNodeElement(container, id2);
    if (element3) {
      const columnId = alignElement(container, element3, behavior);
      if (columnId)
        localState.columns.add(columnId);
    }
  }
};

// src/stores/view/subscriptions/effects/align-branch/align-child-group.ts
var alignChildGroup = (documentState, viewState, container, childGroups, columnId, behavior) => {
  const lastActiveNodeOfGroup = lastActiveNodeOfGroups[columnId];
  const groupWithPreviousActiveNode = lastActiveNodeOfGroup && childGroups.find((g) => lastActiveNodeOfGroup.groupId === g.parentId);
  const columnElement = getNodeElement(container, columnId);
  if (!columnElement)
    return;
  let element2 = null;
  if (groupWithPreviousActiveNode) {
    element2 = getNodeElement(columnElement, lastActiveNodeOfGroup.nodeId);
  }
  if (element2)
    alignElement(container, element2, behavior);
  else {
    const elements = [];
    if (columnElement) {
      for (const childGroup of viewState.document.activeBranch.childGroups) {
        const element3 = getNodeElement(
          columnElement,
          "group-" + childGroup
        );
        if (element3) {
          elements.push(element3);
        }
      }
      alignElement(
        container,
        elements.length > 1 ? elements : elements[0],
        behavior
      );
    }
  }
};

// src/stores/view/subscriptions/effects/align-branch/align-inactive-column.ts
var alignInactiveColumn = (column, container, behavior) => {
  const nodes = column.groups.map((g) => g.nodes).flat();
  if (nodes.length > 0) {
    const element2 = getNodeElement(container, nodes[nodes.length - 1]);
    if (element2)
      alignElement(container, element2, behavior);
  }
};

// src/stores/view/subscriptions/effects/align-branch/align-branch.ts
var import_obsidian5 = require("obsidian");
var alignBranch = (documentState, viewState, container, behavior) => {
  if (!container)
    return;
  const nodeId = viewState.document.activeNode;
  if (!nodeId)
    return;
  const localState = {
    columns: /* @__PURE__ */ new Set()
  };
  alignParentsAndActiveNode(
    documentState,
    viewState,
    container,
    localState,
    behavior
  );
  for (const column of documentState.document.columns) {
    if (localState.columns.has(column.id))
      continue;
    const childGroups = column.groups.filter(
      (g) => viewState.document.activeBranch.childGroups.has(g.parentId)
    );
    if (childGroups.length > 0) {
      alignChildGroup(
        documentState,
        viewState,
        container,
        childGroups,
        column.id,
        behavior
      );
    } else {
      alignInactiveColumn(column, container, behavior);
    }
  }
};
var alignBranchDebounced = (0, import_obsidian5.debounce)(alignBranch, 32);
var lastActiveNodeOfGroups = {};

// node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys2) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys2.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys2 = []) {
    this.keys = keys2;
    this._keysMap = {};
    keys2.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys2, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys: keys2, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys2 = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys2[0]
    };
    keys2.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys: keys2, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys2.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/stores/view/subscriptions/actions/update-search-results/helpers/perform-search.ts
var searchState = {
  fuse: /* @__PURE__ */ new Map()
};
var performSearch = (documentStore, query) => {
  let fuse = searchState.fuse.get(documentStore);
  if (!fuse) {
    const documentState = documentStore.getValue();
    const items = [];
    for (const id2 of Object.keys(documentState.document.content)) {
      const content = documentState.document.content[id2]?.content;
      if (content) {
        items.push({
          id: id2,
          content
        });
      }
    }
    fuse = new Fuse(items, {
      keys: ["content"],
      threshold: 0.4,
      shouldSort: true,
      isCaseSensitive: false,
      ignoreLocation: true
    });
    searchState.fuse.set(documentStore, fuse);
  }
  return fuse.search(query);
};

// src/stores/view/subscriptions/actions/update-search-results/update-search-results.ts
var updateSearchResults = (documentStore, viewStore) => {
  {
    const viewState = viewStore.getValue();
    const query = viewState.search.query;
    if (query) {
      const results = performSearch(documentStore, query);
      viewStore.dispatch({
        type: "SEARCH/SET_RESULTS",
        payload: {
          results: results.map((r) => r.item.id)
        }
      });
      const shouldUpdateActiveNode = results.length > 0 && !results.find(
        (r) => r.item.id === viewStore.getValue().document.activeNode
      );
      if (shouldUpdateActiveNode) {
        viewStore.dispatch({
          type: "DOCUMENT/SET_ACTIVE_NODE",
          payload: {
            id: results[0].item.id
          }
        });
      }
    }
  }
};

// src/stores/view/subscriptions/actions/update-active-branch.ts
var updateActiveBranch2 = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "UPDATE_ACTIVE_BRANCH",
    payload: {
      columns: documentState.document.columns
    }
  });
};

// src/stores/view/subscriptions/actions/set-active-node.ts
var setActiveNode = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "DOCUMENT/SET_ACTIVE_NODE",
    payload: {
      id: documentState.history.context.activeNodeId
    }
  });
};

// src/stores/view/subscriptions/actions/enable-edit-mode.ts
var enableEditMode2 = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "DOCUMENT/ENABLE_EDIT_MODE",
    payload: {
      nodeId: documentState.history.context.activeNodeId
    }
  });
};

// src/stores/view/subscriptions/actions/remove-obsolete-navigation-items.ts
var removeObsoleteNavigationItems = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "NAVIGATION/REMOVE_OBSOLETE",
    payload: {
      content: documentState.document.content
    }
  });
};

// src/stores/view/subscriptions/effects/focus-container.ts
var focusContainer = (container) => {
  container?.focus();
};

// src/stores/view/subscriptions/helpers/calculate-tree-index.ts
var calculateColumnTreeIndexes = (columns) => {
  const treeIndexDict = {};
  if (columns.length === 0)
    return treeIndexDict;
  for (let nI = 0; nI < columns[0].groups[0].nodes.length; nI++) {
    const node = columns[0].groups[0].nodes[nI];
    treeIndexDict[node] = String(nI + 1);
  }
  for (let cI = 1; cI < columns.length; cI++) {
    const column = columns[cI];
    for (let gI = 0; gI < column.groups.length; gI++) {
      const group = column.groups[gI];
      for (let nI = 0; nI < group.nodes.length; nI++) {
        const node = group.nodes[nI];
        treeIndexDict[node] = treeIndexDict[group.parentId] + "." + (nI + 1);
      }
    }
  }
  return treeIndexDict;
};

// src/stores/view/subscriptions/actions/set-tree-index.ts
var setTreeIndex2 = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "UI/SET_TREE_INDEX",
    payload: {
      treeIndex: calculateColumnTreeIndexes(
        documentState.document.columns
      )
    }
  });
};

// src/stores/view/subscriptions/actions/update-search-results/helpers/reset-search-fuse.ts
var resetSearchFuse = (documentStore) => {
  searchState.fuse.delete(documentStore);
};

// src/stores/view/subscriptions/effects/apply-zoom.ts
var applyZoom = (container, viewState) => {
  const columnsContainer = container.querySelector(".columns");
  const columns = Array.from(
    columnsContainer.querySelectorAll(".column")
  );
  columnsContainer.style.transform = `scale(${viewState.ui.zoomLevel})`;
  for (const column of columns) {
    column.style.height = `${100 / viewState.ui.zoomLevel}vh`;
  }
};

// src/stores/view/subscriptions/helpers/is-empty-document.ts
var isEmptyDocument = (content) => {
  const values = Object.values(content);
  return values.length === 1 && values[0] === null;
};

// src/stores/view/subscriptions/view-subscriptions.ts
var viewEffectsAndActions = (view, action, initialRun, fromDocument) => {
  const documentStore = view.documentStore;
  const documentState = documentStore.getValue();
  const viewStore = view.viewStore;
  const viewState = viewStore.getValue();
  const container = view.container;
  if (initialRun) {
    setTreeIndex2(viewStore, documentState);
    setActiveNode(viewStore, documentState);
    updateActiveBranch2(viewStore, documentState);
    if (view.isActive && isEmptyDocument(documentState.document.content)) {
      enableEditMode2(viewStore, documentState);
    }
    if (view.isActive && container)
      alignBranchDebounced(documentState, viewState, container);
  } else if (action) {
    const type = action.type;
    const e = fromDocument ? getDocumentEventType(type) : getViewEventType(type);
    if (!e)
      return;
    if (e.creationAndDeletion || e.shape || e.changeHistory) {
      setTreeIndex2(viewStore, documentState);
      setActiveNode(viewStore, documentState);
    }
    if (type === "DOCUMENT/INSERT_NODE" && view.isActive) {
      enableEditMode2(viewStore, documentState);
    }
    if (type === "DOCUMENT/DELETE_NODE") {
      removeObsoleteNavigationItems(viewStore, documentState);
    }
    if (e.activeNode || e.activeNodeHistory || e.creationAndDeletion || e.shape || e.changeHistory) {
      updateActiveBranch2(viewStore, documentState);
    }
    if (action.type === "SEARCH/SET_QUERY") {
      updateSearchResults(documentStore, viewStore);
    }
    if (!container || !view.isActive)
      return;
    if (e.zoom) {
      applyZoom(container, viewState);
    }
    if (e.changeHistory || e.content || e.creationAndDeletion || e.shape) {
      resetSearchFuse(documentStore);
      view.saveDocument();
    }
    if (action.type === "DOCUMENT/DISABLE_EDIT_MODE" || e.changeHistory || e.content || e.creationAndDeletion || e.shape) {
      focusContainer(container);
    }
    if (e.activeNode || e.activeNodeHistory || e.zoom || e.search || e.creationAndDeletion || e.shape || e.changeHistory) {
      alignBranchDebounced(
        documentStore.getValue(),
        viewState,
        container
      );
    }
  }
};
var viewSubscriptions = (view) => {
  const unsubFromDocument = view.documentStore.subscribe(
    (documentState, action) => {
      viewEffectsAndActions(view, action, false, true);
    }
  );
  const unsubFromView = view.viewStore.subscribe(
    (viewState, action, initialRun) => {
      viewEffectsAndActions(view, action, initialRun, false);
    }
  );
  return () => {
    unsubFromDocument();
    unsubFromView();
  };
};

// src/obsidian/helpers/inline-editor.ts
var import_obsidian6 = require("obsidian");
var noop2 = async () => {
};
var InlineEditor = class {
  constructor(view) {
    this.view = view;
    this.nodeId = null;
    this.target = null;
    this.onload();
  }
  get activeNode() {
    return this.nodeId;
  }
  getContent() {
    const inlineView = this.leaf.view;
    return inlineView.editor.getValue();
  }
  getCursor() {
    const inlineView = this.leaf.view;
    return inlineView.editor.getCursor();
  }
  setContent(content) {
    const inlineView = this.leaf.view;
    inlineView.__setViewData__(content, true);
  }
  async loadFile(file) {
    await this.leaf.openFile(file, {
      state: {
        inlineEditor: true
      }
    });
    const inlineView = this.leaf.view;
    inlineView.save = noop2;
    inlineView.requestSave = noop2;
    inlineView.__setViewData__ = inlineView.setViewData;
    inlineView.setViewData = noop2;
  }
  loadNode(target, nodeId) {
    const inlineView = this.leaf.view;
    const content = this.view.documentStore.getValue().document.content[nodeId];
    this.setContent(content?.content || "");
    inlineView.editor.setCursor({
      line: inlineView.editor.lastLine(),
      ch: inlineView.editor.getLine(inlineView.editor.lastLine()).length
    });
    target.append(this.rootSplit.containerEl);
    inlineView.editor.focus();
    const editor = target.querySelector(".cm-scroller");
    if (editor)
      adjustHeight(target, editor);
    this.nodeId = nodeId;
    this.target = target;
  }
  unloadNode() {
    this.nodeId = null;
    if (this.target)
      this.target.empty();
    this.target = null;
  }
  onload() {
    const workspace = this.view.plugin.app.workspace;
    this.rootSplit = new import_obsidian6.WorkspaceSplit(workspace, "vertical");
    this.rootSplit.getRoot = () => workspace.rootSplit;
    this.rootSplit.getContainer = () => workspace.rootSplit;
    this.rootSplit.containerEl.addClasses(["lineage-inline-editor"]);
    this.leaf = workspace.createLeafInParent(this.rootSplit, 0);
  }
};

// src/view/view.ts
var FILE_VIEW_TYPE = "lineage";
var LineageView = class _LineageView extends import_obsidian7.TextFileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.onDestroyCallbacks = /* @__PURE__ */ new Set();
    this.onViewStoreError = (error, location, action) => {
      if (action && action.type === "DOCUMENT/LOAD_FILE") {
        if (this.file) {
          delete stores[this.file.path];
          setFileViewType(this.plugin, this.file, this.leaf, "markdown");
        }
      }
      if (!(error instanceof SilentError)) {
        console.error(`[${location}] action: `, action);
        console.error(`[${location}]`, error);
        new import_obsidian7.Notice("Lineage plugin: " + error.message);
      }
    };
    this.saveDocument = async () => {
      const state = clone(this.documentStore.getValue());
      const data = state.file.frontmatter + jsonToMarkdown(
        columnsToJsonTree(
          state.document.columns,
          state.document.content
        )
      );
      if (data !== this.data) {
        this.setViewData(data);
        this.requestSave();
      }
    };
    this.loadInitialData = async () => {
      if (!this.file) {
        throw new Error("view does not have a file");
      }
      const fileHasAStore = stores[this.file.path];
      if (fileHasAStore) {
        this.useExistingStore();
      } else {
        this.createStore();
      }
      this.loadDocumentToStore();
      await this.inlineEditor.loadFile(this.file);
      this.component = new main_default({
        target: this.contentEl,
        props: {
          plugin: this.plugin,
          view: this
        }
      });
      this.container = this.contentEl.querySelector("#columns-container");
      if (!this.container)
        throw new Error("could not find container");
      this.onDestroyCallbacks.add(viewSubscriptions(this));
    };
    this.createStore = () => {
      if (!this.file) {
        throw new Error("view does not have a file");
      }
      stores[this.file.path] = this.documentStore;
      this.documentStore.dispatch({
        type: "FS/SET_FILE_PATH",
        payload: {
          path: this.file.path
        }
      });
    };
    this.useExistingStore = () => {
      if (!this.file)
        return;
      this.documentStore = stores[this.file.path];
    };
    this.loadDocumentToStore = () => {
      const { data, frontmatter } = extractFrontmatter(this.data);
      this.documentStore.dispatch({
        payload: {
          document: { data, frontmatter, position: null }
        },
        type: "DOCUMENT/LOAD_FILE"
      });
    };
    this.documentStore = new Store(
      defaultDocumentState(),
      documentReducer,
      this.onViewStoreError
    );
    this.viewStore = new Store(
      defaultViewState(),
      viewReducer,
      this.onViewStoreError
    );
    this.inlineEditor = new InlineEditor(this);
  }
  get isActive() {
    return this === this.plugin.app.workspace.getActiveViewOfType(_LineageView);
  }
  getViewData() {
    return this.data;
  }
  setViewData(data) {
    if (!this.activeFilePath && this.file) {
      this.activeFilePath = this.file?.path;
      this.loadInitialData();
    }
    this.data = data;
  }
  async onUnloadFile() {
    if (this.component) {
      this.component.$destroy();
    }
    this.activeFilePath = null;
    this.contentEl.empty();
    this.documentStore = new Store(
      defaultDocumentState(),
      documentReducer,
      this.onViewStoreError
    );
    for (const s of this.onDestroyCallbacks) {
      s();
    }
  }
  clear() {
    this.data = "";
  }
  getViewType() {
    return FILE_VIEW_TYPE;
  }
  getIcon() {
    return "list-tree";
  }
  getDisplayText() {
    return this.file ? this.file.basename : "";
  }
  async onOpen() {
  }
  /*private destroyStore = () => {
   const leavesOfType = this.plugin.app.workspace
    .getLeavesOfType(FILE_VIEW_TYPE)
    .filter(
     (l) =>
  	   l.view instanceof LineageView &&
  	   l.view.file?.path === this.activeFilePath &&
  	   l.view !== this,
    );
   if (leavesOfType.length === 0) {
    this.store.dispatch({ type: 'RESET_STORE' });
    if (this.file) delete stores[this.file.path];
   }
  };*/
  async onClose() {
    return this.onUnloadFile();
  }
};

// src/obsidian/patches/set-view-state.ts
var fileViewTypeCache = {};
var subscribeDocumentsTypeCacheToSettings = (plugin) => {
  plugin.settings.subscribe((v) => {
    fileViewTypeCache = v.documents;
  });
};
function setViewState(next) {
  return function(state, ...rest) {
    const isMarkdownView = state.type === "markdown";
    const path = state?.state?.file;
    if (isMarkdownView && fileViewTypeCache[path] && !state.state.inlineEditor) {
      const newState = {
        ...state,
        type: FILE_VIEW_TYPE
      };
      return next.apply(this, [newState, ...rest]);
    } else {
      return next.apply(this, [state, ...rest]);
    }
  };
}

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/stores/settings/settings-reducer.ts
var updateState2 = (store, action) => {
  if (action.type === "SET_DOCUMENT_TYPE_TO_MARKDOWN") {
    delete store.documents[action.payload.path];
  } else if (action.type === "SET_DOCUMENT_TYPE_TO_TREE") {
    store.documents[action.payload.path] = true;
  } else if (action.type === "HISTORY/UPDATE_DOCUMENT_PATH") {
    delete store.documents[action.payload.oldPath];
    store.documents[action.payload.newPath] = true;
  } else if (action.type === "SET_CUSTOM_HOTKEYS") {
    store.hotkeys.customHotkeys = action.payload.customHotkeys;
  }
};
var settingsReducer = (store, action) => {
  updateState2(store, action);
  return store;
};

// src/helpers/deep-merge.ts
var isObject2 = (item) => item && typeof item === "object" && !Array.isArray(item);
var deepMerge = (target, ...sources) => {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject2(target) && isObject2(source)) {
    for (const key in source) {
      if (isObject2(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        deepMerge(target[key], source[key]);
      } else {
        if (typeof target[key] === "undefined")
          Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return deepMerge(target, ...sources);
};

// src/stores/settings/default-settings.ts
var DEFAULT_SETTINGS = () => ({
  documents: {},
  hotkeys: {
    customHotkeys: {}
  }
});

// src/obsidian/events/workspace/register-file-menu-event.ts
var import_obsidian9 = require("obsidian");

// src/obsidian/commands/helpers/create-new-file.ts
var import_obsidian8 = require("obsidian");
var getUniqueFileName = (folderPath, files, basename = "Untitled") => {
  let index = 1;
  let newFileName = basename;
  while (files.includes(`${newFileName}`)) {
    newFileName = `${basename} (${index})`;
    index++;
  }
  return `${folderPath}/${newFileName}`;
};
var createNewFile = async (plugin, folder, data = "", basename) => {
  if (folder) {
    const children2 = folder.children.map((c) => c instanceof import_obsidian8.TFile ? c.basename : null).filter((f) => f);
    const path = getUniqueFileName(folder.path, children2, basename);
    const newFilePath = path + ".md";
    return await plugin.app.vault.create(newFilePath, data);
  }
};

// src/obsidian/commands/helpers/open-file.ts
var openFile = async (plugin, file, newLeaf, mode) => {
  const leaf = plugin.app.workspace.getLeaf(newLeaf);
  await leaf.openFile(file);
  setFileViewType(plugin, file, leaf, mode);
};

// src/obsidian/events/workspace/helpers/get-leaf-of-file.ts
var getLeafOfFile = (plugin, file, viewType) => {
  const leaves = plugin.app.workspace.getLeavesOfType(viewType);
  return leaves.find(
    (l) => l.view?.file?.path === file.path
  );
};

// src/obsidian/events/workspace/helpers/toggle-file-view-type.ts
var toggleFileViewType = (plugin, file, leaf) => {
  const currentModeIsLineage = fileViewTypeCache[file.path];
  const currentViewType = currentModeIsLineage ? "lineage" : "markdown";
  const newViewType = currentModeIsLineage ? "markdown" : "lineage";
  const fileLeaf = leaf || getLeafOfFile(plugin, file, currentViewType);
  setFileViewType(plugin, file, fileLeaf, newViewType);
  if (!fileLeaf)
    openFile(plugin, file, "tab", newViewType);
};

// src/obsidian/events/workspace/register-file-menu-event.ts
var registerFileMenuEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.workspace.on(
      "file-menu",
      (menu, abstractFile, source, leaf) => {
        if (abstractFile instanceof import_obsidian9.TFile) {
          menu.addItem((item) => {
            const isTree = fileViewTypeCache[abstractFile.path];
            item.setTitle(
              isTree ? lang.open_in_editor : lang.open_in_lineage
            );
            item.setIcon(isTree ? "file" : "list-tree");
            item.onClick(async () => {
              toggleFileViewType(plugin, abstractFile, leaf);
            });
          });
        } else if (abstractFile instanceof import_obsidian9.TFolder) {
          menu.addItem((item) => {
            item.setTitle(lang.new_file);
            item.setIcon("list-tree");
            item.onClick(async () => {
              const newFile = await createNewFile(
                plugin,
                abstractFile
              );
              if (newFile) {
                await openFile(
                  plugin,
                  newFile,
                  "tab",
                  "lineage"
                );
              }
            });
          });
        }
      }
    )
  );
};

// src/obsidian/events/vault/register-file-move-event.ts
var import_obsidian10 = require("obsidian");
var registerFileRenameEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian10.TFile) {
        if (fileViewTypeCache[oldPath]) {
          updatePath(oldPath, file.path);
          plugin.settings.dispatch({
            type: "HISTORY/UPDATE_DOCUMENT_PATH",
            payload: {
              newPath: file.path,
              oldPath
            }
          });
        }
      }
    })
  );
};

// src/obsidian/events/vault/register-file-delete-event.ts
var import_obsidian11 = require("obsidian");
var registerFileDeleteEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian11.TFile) {
        if (fileViewTypeCache[file.path]) {
          deletePath(file.path);
          plugin.settings.dispatch({
            type: "SET_DOCUMENT_TYPE_TO_MARKDOWN",
            payload: {
              path: file.path
            }
          });
        }
      }
    })
  );
};

// src/obsidian/commands/add-commands.ts
var import_obsidian13 = require("obsidian");

// src/helpers/slugify.ts
var slugify = (inputString) => {
  return inputString.toLowerCase().replace(/[^a-z0-9]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
};

// src/obsidian/commands/helpers/remove-structural-comments.ts
var import_obsidian12 = require("obsidian");
var removeStructuralComments = async (plugin, file) => {
  if (!file.parent)
    return;
  const data = await plugin.app.vault.read(file);
  const lines = data.split("\n");
  const newLines = [];
  for (const line of lines) {
    if (parseDelimiter(line))
      continue;
    newLines.push(line);
  }
  if (newLines.length < lines.length) {
    const newFile = await createNewFile(
      plugin,
      file.parent,
      newLines.join("\n"),
      file.basename
    );
    if (newFile)
      await openFile(plugin, newFile, "split", "markdown");
  } else {
    new import_obsidian12.Notice(`File ${file.basename} does not have structural comments`);
  }
};

// src/obsidian/commands/add-commands.ts
var createCommands2 = (plugin) => {
  const commands = [];
  const getActiveFile = () => {
    return plugin.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView)?.file || plugin.app.workspace.getActiveViewOfType(LineageView)?.file;
  };
  commands.push({
    name: lang.toggle_lineage_view,
    icon: "list-tree",
    checkCallback: (checking) => {
      const file = getActiveFile();
      if (file) {
        if (checking)
          return true;
        else {
          toggleFileViewType(plugin, file, void 0);
        }
      }
    }
  });
  commands.push({
    name: lang.create_new_file,
    icon: "list-tree",
    callback: async () => {
      const file = getActiveFile();
      let folder = null;
      if (file) {
        folder = file.parent;
      } else {
        folder = plugin.app.vault.getRoot();
      }
      if (folder) {
        const newFile = await createNewFile(plugin, folder);
        if (newFile) {
          await openFile(plugin, newFile, "tab", "lineage");
        }
      }
    }
  });
  commands.push({
    name: lang.toggle_lineage_view,
    icon: "list-tree",
    checkCallback: (checking) => {
      const file = getActiveFile();
      if (file) {
        if (checking)
          return true;
        else
          toggleFileViewType(plugin, file, void 0);
      }
    }
  });
  commands.push({
    name: lang.remove_structural_comments,
    icon: "list-tree",
    checkCallback: (checking) => {
      const file = getActiveFile();
      if (file) {
        if (checking)
          return true;
        else {
          removeStructuralComments(plugin, file);
        }
      }
    }
  });
  return commands;
};
var addCommands = (plugin) => {
  const commands = createCommands2(plugin);
  for (const command of commands) {
    plugin.addCommand({
      ...command,
      id: slugify(command.name)
    });
  }
};

// src/stores/hotkeys/effects/plugin/save-custom-hotkeys.ts
var saveCustomHotkeys = (plugin) => {
  hotkeyStore.subscribe((state, action) => {
    if (action?.type === "HOTKEY/RESET" || action?.type === "HOTKEY/UPDATE") {
      plugin.settings.dispatch({
        type: "SET_CUSTOM_HOTKEYS",
        payload: {
          customHotkeys: state.customHotkeys
        }
      });
    }
  });
};

// src/obsidian/helpers/get-used-hotkeys.ts
var getUsedHotkeys = (plugin) => {
  const app = plugin.app;
  const conflicting = /* @__PURE__ */ new Map();
  const allCommands = {
    ...app.commands.commands,
    ...app.commands.editorCommands
  };
  const customHotkeys = Object.fromEntries(
    Object.entries(app.hotkeyManager.customKeys).map(
      ([name, hotkeys]) => [
        name,
        { hotkeys, name: allCommands[name]?.name || name }
      ]
    )
  );
  const commands = {
    ...allCommands,
    ...customHotkeys
  };
  for (const command of Object.values(commands)) {
    if (command.hotkeys?.length) {
      for (const hotkey of command.hotkeys) {
        const hotkey_string = hotkeyToString(hotkey);
        conflicting.set(hotkey_string, command.name);
      }
    }
  }
  return conflicting;
};

// src/stores/hotkeys/effects/plugin/check-for-hotkey-conflicts.ts
var checkForHotkeyConflicts = (plugin) => {
  return hotkeyStore.subscribe((state, action, firstRun) => {
    if (firstRun || action?.type === "HOTKEY/UPDATE" || action?.type === "HOTKEY/RESET") {
      const conflictingHotkeys = getUsedHotkeys(plugin);
      hotkeyStore.dispatch({
        type: "SET_CONFLICTING_HOTKEYS",
        payload: {
          conflictingHotkeys
        }
      });
    }
  });
};

// src/main.ts
var Lineage = class extends import_obsidian14.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      FILE_VIEW_TYPE,
      (leaf) => new LineageView(leaf, this)
    );
    this.register(around(import_obsidian14.WorkspaceLeaf.prototype, { setViewState }));
    this.registerEvents();
    addCommands(this);
    loadCommands(this);
    this.registerEffects();
  }
  async saveSettings() {
    await this.saveData(this.settings.getValue());
  }
  async loadSettings() {
    const settings = await this.loadData() || {};
    this.settings = new Store(
      deepMerge(settings, DEFAULT_SETTINGS()),
      settingsReducer
    );
    this.settings.subscribe(() => {
      this.saveSettings();
    });
    subscribeDocumentsTypeCacheToSettings(this);
  }
  registerEvents() {
    registerFileMenuEvent(this);
    registerFileRenameEvent(this);
    registerFileDeleteEvent(this);
  }
  registerEffects() {
    checkForHotkeyConflicts(this);
    saveCustomHotkeys(this);
  }
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

lucide-svelte/dist/defaultAttributes.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-left.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-right.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-down.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-right.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-up.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-minus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-output.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-pen.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-plus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-question.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-up.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/history.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/keyboard.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/maximize.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/merge.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pen.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pencil.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/redo.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/rotate-ccw.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/save.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/search.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/trash.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/undo.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/x.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/zoom-in.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/zoom-out.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/index.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/aliases.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
